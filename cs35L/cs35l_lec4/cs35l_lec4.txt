 to use it as sort of a language like this,
 sort of how to get started.
 And the standard way you can get started with a shell
 as an orchestration language or a command language
 is you put a shell script into a file.
 Here's our file F, it's contents in the script,
 but there's a couple of special things about this file
 that tells the operating system this is a shell script
 and not just some nice letter that you're emailing it
 to your mom or something like that.
 First thing is, this file should be executable.
 That is, if you do LS minus L on this file F,
 it should give you something that looks like this.
 Right?
 Where the important parts here are the exbits, right?
 This says that you, that other people in your group,
 and that anyone else can execute this file.
 Ordinarily, files are not executable.
 If you just create a file on your own,
 those exbits will be off.
 You're gonna have to turn it on
 because you're wanting to tell the operating system,
 oh, I want this script to be a program
 that can be run.
 Before we jump further into this,
 I want you to think about why.
 So I'd like to take a step back from,
 I mean, we were talking about Emacs last time
 and spent quite some time, or at least some time,
 talking about Emacs Lisp and all that sort of thing,
 but I want to take a step back a little bit.
 So we've talked about Elis,
 which is the scripting language for Emacs.
 We've also talked about the shell,
 which is an even more stripped down scripting language.
 I mean, even in Elis, you can add numbers pretty effectively
 but the shell addition is not very much.
 So with the shell, it's really the shell plus utilities.
 This is really sort of at some extreme
 of the scripting language.
 It's a scripting language so simple
 you can't do much with it.
 You really have to use extensions.
 So this is the extreme end
 of sort of a little languages approach
 where you take a big problem,
 you split it down into sub-problems
 and maybe use a different programming language
 for each of the sub-problems.
 Elis takes another approach.
 They basically says, you know, do everything in Emacs, right?
 This is sort of the extension languages model.
 (marker tapping)
 For an application.
 So under this approach, you have an application
 like a web browser or a text editor
 and the way that you tailor it or extend it
 or turn it into a somewhat different application
 is you use its extension language,
 which in some sense, why does the operating system
 have this expert?
 Why not just let every file be executable?
 What's the point of the Xbit?
 Any thoughts?
 Wouldn't the system be simpler without the Xbit, right?
 Then we'd have less to teach.
 Simplicity is good.
 Yes.
 (man speaking off mic)
 You could have malware, right?
 So, okay.
 In some sense, what the Xbit is telling you
 that are setting the Xbit
 and other people that are looking at the files
 is watch out, right?
 This file, because it contains commands that can be run,
 it's a little bit dangerous, right?
 You should be cautious about this file.
 If you run it, it will run with all of your privileges
 and it can do whatever you can do
 and so that Xbit in some sense is a sign of, you know,
 let's be careful about this file.
 If I wander into some random directory
 and see a bunch of files with the Xbit turned on,
 I get a little cautious, right?
 I don't execute those programs
 unless they're from a source that I trust,
 like I wrote them, that sort of thing, all right?
 So that Xbit is there for security or reliability
 or whatever you want to call it, all right?
 Notice that for a shell script though,
 the Rbit also has to be on.
 What, since uses the core part of Emacs
 the same way that the shell uses utilities like cat and sort.
 These are not the only two scripting languages, obviously.
 There's a bunch of others out there.
 Some include things like Perl and PHP.
 The one we'll talk about,
 the other P scripting language is Python.
 By some measures Python is now
 the world's most popular programming language of any sort,
 scripting, conventional, you name it, right?
 It's used a lot.
 My assumption is that many of you
 have been exposed to Python already.
 Let's test that.
 If you've written some Python code, raise your hand.
 Oh, good, all right?
 Not everybody raised their hand.
 So I will do a quick introduction to Python
 because the shell is a program.
 It reads your script, figures out what it'll do
 and then executes it.
 If it can't read your script, it can't read Python.
 By the end of this lecture, you'll all be Python experts.
 Wait, most of you are Python experts anyway.
 So I have a problem here, right?
 I have to talk about a scripting language
 that most of you know and I have to talk about it
 in a way that, just run it, right?
 So you need both the R and the X bit turned on
 for a shell script to work.
 Second thing you need is at the very start,
 you need to put a little comment at the start of your file
 in the shell, sharp sign at the start of a word says,
 okay, here's a comment.
 Everything from here to the new line doesn't count.
 So here's a comment.
 And this comment has to look something like this.
 That is, it has to have an exclamation point
 right next to the hash mark.
 And then after that has to be the program
 that knows how to execute this script.
 In our case, it's /bin/sh,
 which is the standard place
 where you're gonna find the shell.
 On this machine,
 we can see that /bin/sh
 is going to be the symbolic link to bash.
 On some other machines,
 they might use a different implementation of the shell,
 but the convention is that particular file,
 pretty much anybody who doesn't know Python could understand
 and I still have to say something interesting.
 This is gonna be a challenge.
 Anyhow, well, one other scripting language
 before we jump into Python
 that I should mention is JavaScript.
 You can think of JavaScript as behaving inside your browser
 as Elisk behaves inside Emacs.
 It's an extension language for Chrome
 or for whatever your favorite browser is
 and all that sort of thing.
 So these two are kind of very similar models.
 Extension language for an app.
 The shell is sort of off on its own planet.
 These guys are all roughly similar
 in that the attitude here is that
 you really program in these languages,
 you can get useful work done
 without sort of anything else, right?
 These are standalone languages
 and lots of people write useful code
 that will work just with these languages.
 However, it's safe to say that with these,
 even with these standalone scripting languages,
 it's fairly common to have plugin modules
 and these plugins will be written in C++
 or file name will be either a regular file
 or a symbolic link to something that can run shell scripts.
 Now, you could, if you like, put something else here.
 You could say, I don't know, user bin Python.
 In that case, this script is gonna have to be
 Python source code rather than shell code, right?
 Because what the operating system will do
 is it'll take that first line and say,
 okay, that's going to be the name of the interpreter
 and then it'll run the interpreter
 and the interpreter will figure out
 what to do from there on out
 and it will look at the script source code.
 We're not quite ready for Python,
 so let's stick with the shell, okay?
 We'll go back to bin sh.
 Now, question.
 - There's no space between the X and Y combination?
 - Oh, opinions differ on whether a space is allowed here.
 Some people like it.
 I don't, but you know, it's a style thing, I think.
 Yes.
 - You have to use the absolute pattern of the space, right?
 - Yes, it has to start with a slash.
 Otherwise, the command would be kind of tricky, right?
 It might use a completely different interpreter
 if you ran it from a different location,
 so by convention C or some other low-level language
 that will give you extra performance
 compared to writing code in Python.
 Python code is just, you know,
 even though we've tried to make Python go fast
 and there's various strategies for making it go even faster,
 it's just not gonna be as fast as well-tuned,
 you know, assembly language or C++ code.
 So the plugins are a fairly important part
 of using Python for doing big computations.
 In your assignment,
 you don't need to worry about the plugins.
 You're just using it as a standalone language.
 For those of you that know Python well,
 I suppose it's a warmup.
 For those of you that don't know Python,
 we'll sort of be learning as we go.
 All right, so let's do a little Python.
 I just started up a Python thing here,
 and let's assume that I'm interested
 in trading in the stock market,
 and I just found the quote for Google stock,
 Alphabet, I suppose it's called,
 and I get a line out of my web browser,
 or I'm screen scraping,
 or I get some other data source that looks like this.
 All right, so line is a top-level variable
 in this Python code.
 I'm just typing using Python interactively here.
 So I can ask it questions like,
 what's the value of line?
 If I just do something like this,
 it's the same as saying two plus three, right?
 It just gives you the answer.
 So we're in a normal redevelopment,
 and it starts with a slash.
 All right, question.
 - So with the Python script,
 I know that you meant it was about pi,
 and then you write out what you want,
 and then there was this interpretive one.
 Is there a way to do that with just the result
 of this kind of extension?
 - Typically, shell scripts,
 if they have an extension, it would be .sh,
 but I usually don't put .sh in my shell script names,
 because then I have to type .sh to run it, right?
 So I'm lazy, and I just call it f,
 or sort, or something like that.
 Other comments on how to get started?
 Question?
 - The box is like--
 - The content, this is the whole contents of the file, right?
 So we can create a shell script here
 by doing something like, I'll call mine foo,
 since I'm not very creative.
 Really good programmers write their code with cat.
 That's what I'm doing here, right?
 So we can say sort everything on the input,
 and then what should we do with the result?
 We'll transliterate all of the lowercase letters
 to uppercase letters.
 Sort of like the emacs scratch buffer,
 where you type control J, and it evaluates for you.
 But suppose I want to do something with this line.
 I want to analyze it.
 I want to get the data out of it.
 Fairly common approach,
 a fairly common task for Python apps
 is to take perhaps somewhat messy data
 from some data source,
 and convert it into some internal clean data format, right?
 So what I can do with this thing
 is do something like the following.
 I'm going to say, okay, the types of the data
 in this text string,
 this is just an ordinary character string,
 are the following.
 Goog is the stock market label.
 So the Python data type for that is string,
 which is spelled S-T-R.
 The number 100 is the number of shares
 of alphabet stock that I have, right?
 So that's going to be an integer.
 And then the third value here is the price of the stock,
 which is a decimal number.
 It always has, oh, did I mess up, right?
 And then I'm going to type control D here.
 So now I've written my shell script, right?
 I can now say cat foo, there it is.
 But if I do an L-S minus L foo,
 notice it's not executable.
 So let's make it executable by doing something like this.
 Chmod is a command that changes the mode
 or the permissions in a file.
 So we said, that's supposed to be 0.88.
 We'll have to go fix that.
 But we'll model that as a floating point number.
 All right?
 And I'm going to go, please turn on the X bit.
 And that's what chmod did.
 And now I can run the command foo
 by saying something like this, et cetera, password, right?
 And what's going to happen here is
 the script will be invoked and that special variable,
 dollar sign, at sign, in quotes.
 In quotes.
 We'll turn into the arguments that get passed to the script.
 So this thing gets expanded to et cetera, password.
 And it's as if we run the command sort, et cetera, password,
 and then transliterate all lowercase letters
 to uppercase letters.
 And that's probably going to give us a lot of output.
 So let's just take a look at the line again here.
 Line equals goog 100, 156.88.
 So what I'd like to do here is scrape the data
 out of that character string.
 But sort of interpret each field as I go
 according to the types that I've written down here.
 And notice types is just another value.
 It's a Python list and it's components of the list.
 It's got three items.
 Each item in the list is a class that is a data type, right?
 And so what we've done here is we have a list of types.
 This is not something you can do in C++, right?
 In C++, you can have lists of things,
 but types are not runtime objects.
 Python takes quite a different attitude.
 As a scripting language, it doesn't mind
 having everything sort of available at runtime.
 So if you have a data type,
 that data type is just another object in Python, right?
 If you type int, that's an identifier.
 Its value is an object.
 This object happens to be a class or a type,
 but it's the same thing as, in some sense,
 it's the same thing as line as a string.
 Okay, int is a class.
 All right, so look at the first five lines of output,
 something like that, right?
 So this is the result of running that command.
 The original et cetera password
 had a bunch of lowercase letters.
 We sorted it and then we uppercased the result, okay?
 So notice what happened here in this command
 is I invoked a shell script
 as sort of a subcommand of a larger pipeline.
 So we nested a command that we wrote in the shell
 inside the pipeline, and that command turned around
 and did some more shell stuff.
 This sort of thing is quite common.
 You're going to have multiple instances of the shell
 running at any given time,
 and each instance is a program, right?
 So each sort of process
 has, as I mentioned last time, a working directory.
 (typing)
 And it has its own idea of what standard input is,
 and standard output, and standard error.
 And it has some other stuff, but we'll start with these.
 And one of the things that you do with the shell
 is you arrange for your subsidiary, let's do this.
 What I'm gonna do is I'm going to take that line,
 it's not lines, and I'm going to split it, right?
 So Python has a built-in method for strings called split.
 You give that method an argument
 that specifies the separator
 that you want to split that string on,
 and what it's going to do
 is it's going to give you a list of strings,
 one for each field that it found
 separated by the separator, right?
 So let's call that LS, right?
 And LS thus is now a list of strings,
 programs, your subsidiary processes,
 to have the proper working directories
 and the proper stand-in, stand-out, and standard error,
 that sort of thing.
 So for example, if we did something like this, CD, et cetera,
 and then run sort password, right?
 And then we'll do the TR business again.
 Well, this time I'll make it, yeah, why not, Z, and then head.
 Then notice what happened here is
 inside those parentheses, we ran CD,
 but everything in the parentheses
 is run in a subcommand, a subshell,
 so that sort's working directory was et cetera,
 but our own working directory
 is still the same thing that it was before.
 It hasn't affected the current working shell.
 We're still in my home directory
 under the CS35L subdirectory, right?
 So each process has this, and the shell and subshells,
 a lot of what they do is to set this stuff up, right?
 Because this is part of the process environment,
 and because the shell is an oracle,
 each string is the component that we wanted.
 All right, now what we can do here
 is we can do something like this,
 for I in LS, we can print I, right?
 And what print does is it's a standard Python function.
 It just prints out its argument.
 We've iterated through that list,
 and for each item in the list,
 we've printed out the string that we found.
 We can also do that with our list of types,
 so we can say for I in types, right?
 Print I, same thing.
 Now, it's fairly common when you have two lists,
 and you want to sort of take the elements pairwise
 and do something with them to zip them up, right?
 So a zip, there's a function in Python called zip, right?
 And what zip does is you give it two lists,
 you know, A, B, C, D, E,
 and another list, nine, seven, two, one, zero, right?
 Here are two lists.
 When you zip them together, it's like a zipper
 that sort of runs through the elements
 of each of these lists, and every time you ask the zipper,
 can you kind of give me another, a pair?
 It gives you the next pair.
 So you can think of this as sort of doing this,
 it just does a pairwise zip up of the two,
 and then E, zero,
 where these things are pairs,
 they're tuples with two items in them,
 we have a list of pairs,
 and what we've done is we've just--
 - Frustration language, a good chunk of the work
 that it does is setting up the environment
 for each of the commands that it runs.
 All right, so any questions about the big picture?
 Yes?
 (muffled speaking)
 What's after dot slash foo?
 Oh, so yes, that's command line number 23, right?
 So what we're doing there is we're calling two commands.
 The first one is dot slash foo,
 which is, you know, dot is the working directory,
 dot slash foo is the file foo
 in the current working directory.
 It's the file foo that we just created up there
 with our cat command.
 Then we have a vertical bar,
 and then we're running the head command.
 The head command is a very simple command.
 You give it a number of lines,
 and it reads standard input, that many lines,
 copies them to standard output, and then it quits, right?
 So it gives you the first N lines
 of the input that it saw, right?
 So line number 23 runs our foo command,
 and it also says take all of its output
 and throw most of it away.
 Just show me the first five lines.
 The rest of the output is just discarded.
 What does foo do?
 Well, if you look at line--
 - Just done a pairwise zip up.
 - It's like the way that the zipper works
 and the tines sort of intertwine
 and all that sort of thing.
 All right, question?
 - Does zip still run if you use two arrays
 and they're not of equal?
 - If one list is shorter than the other,
 it stops at the shorter one.
 There's no error.
 It just says, ah, you've got a zipper where, you know,
 has that ever happened to you?
 The zipper gets misaligned,
 and then one is longer than the other,
 and you just zip up as far as it goes, and then it stops.
 All right, so let's use that function,
 and we'll put the result in the local variable z.
 So we'll do zip, z equals zip of types,
 and what was it, ls, right?
 So we've now created something like this,
 but I did a little bit of hand-waving there
 because what we have here, if I just type out and say,
 hey, what's a z?
 We actually don't have a list of pairs.
 We have something called a zip object.
 A zip object kind of acts like a list of pairs,
 except it's kind of lazy.
 It doesn't actually construct the pairs until you ask it to.
 One way you can ask it to is you can iterate
 through a zip object, right?
 So you can say for i in z, command line number 18.
 You can see the contents of foo.
 What it does is it sorts the contents of et cetera,
 password, and then transliterates lowercase to uppercase.
 I mean, we could have done it directly.
 We could have said something like this, et cetera, password,
 right, and then transliterate.
 (mouse clicking)
 And then take care of the result.
 All right, so that's equivalent, except in line 23,
 we decided to use the foo implementation,
 you know, foo as a shorthand for sort and transliterate
 rather than do it all ourselves.
 Yes.
 - In previous lectures, you mentioned that programs
 are different from foo, so when we actually create--
 - It's just a program, it's not running yet.
 So creating the script, it's like writing a C++ program.
 It's not actually running yet.
 A process is a program in execution.
 - Oh, so even if it, so if you don't run it,
 it's, you know, we don't have any policy yet.
 - Correct.
 You can print i, all right?
 And what it's going to do here is it's going to print
 each pair in that zip object as you, right,
 the processor only gets created
 once you start running the program.
 Yes.
 (student speaking off mic)
 - We added executable permissions.
 - As you compute it, and then, you know,
 then we'll be done when we're done iterating through it.
 Okay.
 So far, so good, right?
 Now, what I want to do in order to analyze
 this character string that I've split up,
 and I've now told Python which type
 to apply to each of these, is I'd like to convert
 that string, 158.88, which is a character string.
 I want to actually know the number.
 I want to convert it to float, right?
 And I want to convert that character string, 100,
 to the integer 100.
 Goog is already a string.
 I'll just want to leave it as a string.
 Luckily for me, Python classes have constructors,
 and you can do something like this.
 Float is a class.
 It's a type.
 But you can give it a character string.
 I keep hitting my thing.
 All right, so let's try it again.
 3.14, right?
 And then it will convert that character string
 to a floating point number.
 The--
 (student speaking off mic)
 Right.
 (student speaking off mic)
 (student speaking off mic)
 So for example, I could at this point say
 chmod user minus x foo,
 and now I can't run foo, but everybody else can, right?
 Or we can say chmod g minus x foo.
 Now, oops.
 Notice that foo is going to be something
 that anybody that's not me and not in my group can run it,
 but my group and I can't run it.
 So you can even do stuff like this.
 Chmod, I don't know, ug plus wx.
 This gives write and execute permission
 to the user and the group, and that's it.
 So when we're done, oh, well, we need to give it,
 tell it what we want, right?
 And now notice that I have my permissions back.
 Question.
 (student speaking off mic)
 The dollar sign at.
 Oh, so dollar sign at expands to all the arguments
 that were passed to your shell script,
 and if there's more than one argument,
 then this basically turns into each argument
 as a separate word, right?
 So if we, let's just float approximation to 3.14, right?
 So what I'd like to do is I'd like to treat float,
 my class float as a function,
 and apply that to the character string 15888.
 I'd like to treat integer as a function,
 and so forth and so on.
 So one way I can do that is I can say,
 let's do something like this.
 (student speaking off mic)
 All right, this is what's called
 a list comprehension in Python,
 and what we're doing here is we have this little
 kind of for loop inside the square brackets
 that says I'd like to iterate through z, okay?
 And each time I iterate through z,
 I know I'll get a pair,
 and I'd like to take, call the first item in that pair t,
 and the second item in that pair v, right?
 So the first time I iterate, t will be the class str,
 and v will be the string gog,
 and then what I wanna do is compute t of v.
 I'll call t with v being its argument.
 So the first time through the iteration, how should I say it?
 So suppose I invoke something like this.
 Then foo would be given three arguments.
 And so when we run the contents of foo,
 oh, I see we've lost the contents of foo off the screen,
 so we'll put it back again, right?
 It's as if we typed sort a, b, c, d, e, f,
 a separate strings, and I'll double quote them on.
 And notice that the fact that there's a space in here
 doesn't mean that it turns into four arguments here.
 It's still just three.
 So if you're being very careful about arguments in a script,
 you typically want to quote them in case they have spaces
 or any funny characters in them.
 And if you quote them this way,
 then you preserve the actual number of arguments
 that you originally had.
 Yes?
 - If you put in a file instead of just a string literal
 as an argument, would it split the file
 into each of the words in the script?
 - No, as far as the script is concerned,
 this is just a string operation.
 The shell doesn't care whether or not the arguments
 to the script are file names or options or anything else.
 This just expands to them all, okay?
 Other comments in the back, yes?
 (audience member speaks off microphone)
 I will get the string G-O-O-G, because STR is a no op.
 When you give it a string, it says,
 that's already a string, I'll just give it to you.
 The second time through the loop,
 I will call the class int with the string argument 100.
 It'll give me the integer 100.
 And the third time it iterates, I'll call float, all right?
 Question?
 (audience member speaks off microphone)
 (audience member speaks off microphone)
 - Right, this is something that you can iterate through.
 Yeah, the Python-ish terminology for that is iterable, right?
 (audience member speaks off microphone)
 Right, well, I don't know, can you do something like this?
 It's not working, what did I do wrong?
 Z is a zip object.
 I have, so this is types, this is LS.
 And I thought, why do we need a dash
 before the dollar sign, oh, you mean the double quote?
 (audience member speaks off microphone)
 Why don't we put it like a hyphen in front like this?
 Oh, because as far, I mean, you could,
 this is valid shell code,
 except I would never see it probably,
 'cause this means expand all the arguments
 that were given me, but I want a minus sign
 in front of the first one.
 Normally, that's not what I want.
 I would just want the arguments that were given to me as is.
 Other question, yes?
 (audience member speaks off microphone)
 Yeah, TR is short for transliterate.
 And so, in its simplest form, you do something like this,
 T-R-A-Q, and then every line you type, every A turns into a Q.
 You can make it more complicated
 by saying something like this,
 T-R-A-B-Q-R, and then it changes every A.
 I could do something like this, tie TV.
 (mumbles)
 TV in zip, types, I don't know, line.split, colon,
 comma, like that, right?
 And then that, and then that, there we go, it worked.
 All right, so the idea here is I did the zip,
 the zip gave me a zip object,
 I iterated through that object each time
 through that iteration to a Q and every B to an R.
 And by extension, you can say something like
 T-R-A through E, I don't know, capital A through capital E,
 and that's equivalent to saying T-R-A-B-C-D-E-A-B-C-D.
 I called T of V, because T was first bound to S-T-R,
 V was first bound to goog,
 and then this list comprehension basically
 gives me the list of all the results I got
 by calling T of V each time.
 Question?
 The very last thing, it's called a list comprehension, right?
 It's almost like you can, in set theory,
 you can say something like this, right?
 X squared such that, you know,
 zero is less than or equal to X is less than 10,
 and X is an integer, right?
 So this construction, but at its heart,
 T-R is just a transliteration program.
 It's very simple, read a byte,
 take a look if I should transliterate it.
 If so, you know, do that,
 otherwise just output the byte as is.
 Yes?
 - In terms of standard input and output,
 can we use transliterate the same way as hat?
 - T-R doesn't take file names as input.
 It only takes operands that tell it how to transliterate.
 So it always reads from standard input
 and it always writes to standard output.
 So in that way, in that sense, it's less fancy than cat.
 Other comments about these examples?
 Yes?
 (muffled speaking)
 (muffled speaking)
 Yes, the arguments to T-R are,
 they're not regular expressions,
 so we'll start with that, right?
 It's a special syntax used only by T-R,
 tracks the list of all the squares
 of all the integers from zero up through nine, right?
 And this terminology, this notation here,
 tries to mimic that sort of mathematical notation,
 except here we're not talking about sets,
 we're talking about lists.
 Question?
 (muffled speaking)
 I don't know.
 That's what's mystifying me.
 That is, we got some empty lists there,
 and what, oh, oh, I know what happened.
 What a stupid thing.
 Oh, oh, I should be, I should be,
 I should be re-educated.
 What happened was that first loop for I and Z,
 it iterated through Z.
 Now Z has been iterated through.
 If you try to keep going, it'll say, I'm sorry,
 I'm all out of entries, right?
 So an iterator remembers where it is,
 and if you try to iterate through an entire iterator,
 and then say, oh, I'd like to iterate
 through that iterator again,
 it'll say, I'm sorry, there's no more.
 So that's why it gave me the empty string.
 My apologies.
 So the reason it worked at the end is I called zip again,
 and I called, it gave me a new, fresh iterator,
 and then I could use it the way I wanted to.
 Yes?
 (muffled speaking)
 And you can think of it as being sort of like the contents
 of a bracket of expression in a regular expression.
 That's kind of what they look like.
 But it's not exactly that as well.
 If you wanna find out exactly what it is,
 you look at the documentation, right?
 Info, tr, here we go.
 Lots of stuff here.
 Or if you prefer it, you don't like this sort of thing,
 you can type man, tr,
 and find the documentation in a different form.
 There's a bunch of explanation about it,
 but it's, no, it's not quite the same
 as regular expressions.
 It was designed by somebody who wasn't
 in either of the two camps I talked about last time.
 Yes?
 (muffled speaking)
 (muffled speaking)
 So how does a program know whether it's a shell script?
 - Yeah.
 - Well, I mean, it's not that,
 the program doesn't know anything.
 A program is just a program, right?
 It's how does the operating system know
 that when it's executing a file,
 it's executing a shell script,
 as opposed to maybe some other, please?
 (muffled speaking)
 So I created an iterator's executable machine code,
 like, you know, the cat itself,
 that's written in machine code.
 The way that it knows is it looks
 at the first few bytes of the file.
 If they sort of like a quarter of a way down a string thing
 when I called zip, right?
 And then I used it in that for I and Z.
 And each time you sort of use an iterator,
 you can just ask an iterator, give me the next guy, right?
 And then it'll advance one, and then you can ask it,
 give me the next, it'll advance one.
 The for loop, that for I and Z loop about midway through,
 went through the entire iterator.
 It chewed up every sort of pair
 the iterator was willing to give it.
 And so at that point, if you go to the iterator and say,
 I'd like some more, it says, I'm sorry,
 I'm the empty iterator now.
 Question?
 (muffled speaking)
 Not in general.
 Some iterators you can do it, some you can't.
 Let's not go that way, all right?
 Because part of the problem is the iterators
 that try to be efficient,
 try to sort of discard information as quickly as they can.
 So they won't in general be something that you can reset.
 Question?
 (muffled speaking)
 (muffled speaking)
 Well, yeah, you can use a for loop to go through a list.
 They look like this, it's a shell script, right?
 If they look like this except Python, it's a Python script.
 If it's machine code, there is a different byte pattern
 at the very start of the file
 that tells the operating system,
 I'm machine code, that sort of thing.
 And that's something that maybe CS 33 will talk about,
 but I don't talk about.
 Question?
 (muffled speaking)
 Right, will be a shell script, yes.
 (muffled speaking)
 You wanted to run the script several times?
 Oh, well, we can do that here, right?
 We can say dot slash foo a and then dot slash foo b, right?
 That is, or we can even do something like this.
 Dot slash foo of, I don't know, et cetera, password,
 and then pipe it into dot slash foo, right?
 So foo is a program.
 It can be run as many times as you want.
 And in this last example,
 we're running two instances of foo in parallel.
 They each have their own process.
 It's the same program,
 but two different processes are running it,
 and they might behave differently because of that.
 (muffled speaking)
 Is the name of the what?
 (muffled speaking)
 Right?
 Each time you do that, and in effect,
 it creates a new iterator to go through that list
 that particular time, right?
 So lists can be iterated through
 because it just constructs an iterator
 for that particular for loop.
 So I get the sense that even though, you know,
 a good chunk of the class knew Python before walking in,
 they didn't see this little introductory thing.
 This is, I was supposed to just give you
 three lines of Python code to warm up,
 and we've already explored parts of Python
 that perhaps are new to some of you, right?
 Part of what's going on here is it's a big ecosystem, right?
 I don't know all of Python.
 Nobody in this room knows all of Python, right?
 We have to be careful here.
 In such a large system, you know,
 you can't assume you know everything.
 The goal in sort of building software in these large systems
 is to figure out what makes them tick,
 and to get that central model of computation working, right?
 And once you do that, you can treat that central model
 as something you understand,
 and there'll be stuff out in the periphery that's optional,
 and you can, so you're saying where did TR come from,
 that sort of thing, or?
 - No, like that's a script that you're running
 on the camera together, right?
 - Oh, yeah, so, well, here I would say
 I'm not really running a script.
 I mean, I'm just using the shell
 as a command line interface in line 38.
 I'm saying please run the TR command,
 and use it, give it these arguments.
 TR reads from standard input.
 I typed standard input, and then typed control D.
 So I'm just running commands.
 And I don't, when I'm running them,
 I don't care whether TR is written in machine code,
 or shell script.
 From my point of view, it works either way, right?
 Yes?
 - So in the example you just typed out,
 where you're typing the output of the first one,
 the second one, that wouldn't work, right?
 'Cause it would take the output of,
 and then pass it over, and that's where I'm typing.
 - Well, here's foo, all right?
 And so if I type 44, it's equivalent to saying this, right?
 Sort, et cetera, password,
 and then pipe the result through TR, A through Z,
 A through Z, and then pipe the result,
 and not use it if you don't care,
 and all that sort of thing.
 But you really have to have that central model nailed down.
 So to some extent, what I wanted to do in this lecture,
 is cover what I think the central model is.
 Now, other people might disagree.
 I don't claim to be a Python expert, right?
 I don't think I'm an expert in a programming language
 until I've written 10 or 20,000 lines of code,
 and I've written Python code, but not that much.
 Is there anybody here who's a Python expert?
 Oh, well, I certainly intimidated people with that, right?
 All right, so that's fine.
 The point here is, you have to know what the core is,
 you have to know how to come up to speed
 in any particular sub-area of Python that you need to learn,
 and you need to sort of gain that expertise
 in coming up to speed.
 All right, anyhow, enough of a sales pitch.
 I hope I've convinced you that Python is worth learning,
 and also it might be a little trickier than we thought.
 Is there a question in the back?
 Okay, all right, so.
 Before jumping into more details,
 let's do a little bit of history.
 Result through foo again, well, that's sort,
 piped through TR of A through Z, A through Z.
 This is not a command that is really all that useful, right,
 because it's kind of transliterating twice
 and all that sort of thing, but it does work.
 So yeah, I could run foo and pipe its output into foo,
 and that will work.
 - So I guess I'm a little confused
 because it's sort pipe, like in a second part of Python.
 How did it get here?
 - How did I get here?
 - So yeah, the last type of function.
 - This very last one?
 Oh, because what I was trying to do
 is I was trying to explain how foo would work
 if you said dot slash foo, et cetera, password, right?
 And then pipe the result through dot slash foo.
 And if, well, I didn't mean to run that, sorry.
 And then if you cat foo, you'll see what foo does.
 And so you can mentally expand.
 Every time you see a foo as a command, it turns into this.
 So I had mentally expanded it twice,
 and I gave you the two sort of.
 And I want to talk about history,
 partly because I was there,
 and partly because I want to sort of show you
 part of the motivation for this programming language.
 And the motivation helps explain many of its features
 and many of the longer pipeline with four subcommands in it
 as equivalent to being the shorter one with two.
 All right, other comments about that?
 Yes, if it's non-featured, all right.
 So we can start off with the shell.
 And the shell, you know, plus utilities.
 And what people found when they wrote the utilities
 is they needed to do stuff with files
 and all that sort of thing.
 But in particular, there were text utilities.
 Like awk and sed, that I haven't said much about,
 because nowadays people typically
 write this stuff in Python, right?
 But awk and sed and other commands like that
 were programs, basically,
 you fed them text on standard input,
 and they output different text on standard output.
 So they were text processing utilities.
 And, you know, you can write
 sort of arbitrarily complicated programs here.
 This fits into the model of little languages.
 Louder, please.
 (audience member speaking off mic)
 Because I was just trying to explain this line 47,
 which is, it's not a very useful line.
 It's a toy example, and you're right.
 It's running sort twice, and what's the point, right?
 It's just going to give the same output.
 But I was merely trying to explain what line 47 does.
 All right, other comments?
 All right, so we've talked about sort of orchestration.
 And now I wanted to talk about
 sort of a bit of shell syntax.
 We started that last time when I talked about tokens.
 And I hope you remember everything there is.
 Stuff was all written in the 1970s.
 So in the 1980s, in a guarded,
 to remember about tokens and quoting
 and all that sort of thing,
 as an aside, quoting is a big deal.
 In every language, you'd better know how things are quoted.
 Because quoting is what basically tells you
 what's program and what's data.
 The stuff inside the quotes is data.
 The stuff outside the stuff building in Santa Monica.
 There was a fellow named Larry Wall
 who knew all this stuff.
 And the quotes is program.
 You need to know the difference.
 But now that we've gotten that difference,
 what can we do with it?
 We have in the shell some,
 used these utilities and couldn't stand them.
 And the reason he couldn't stand them,
 he said, I've got to learn five programming languages
 just to do this sort cleanup table thing.
 You gotta be kidding me, right?
 What we need is we need to have a single program
 that can do the combination of what the shell can do
 and what all these text utilities could do.
 And do it all in sort of one integrated language, right?
 Full time, he was working on network security.
 I happen to know this 'cause I worked down the hall from him
 except between him and me, there was an armed guard, right?
 So this is very hush, hush, top secret stuff.
 But in his spare time,
 he wrote a scripting language called Perl.
 And what Perl did was all of this stuff,
 but in one notation so that you didn't have to learn
 five languages, you could just learn Perl.
 Reserved words.
 They act a little bit like the keywords in C++,
 but they're not as reserved as they are in C++.
 They're reserved only in the sense that
 you can't have a command whose name is the same
 as one of these reserved words, right?
 And so here are some of the reserved words,
 just exclamation point, right?
 So if I start a command with an exclamation point,
 that basically says, I can put something in here,
 I can say grep x, right?
 Put anything in here I like.
 But if I put an explanation point followed by a space,
 what this says is, I want this bigger command
 to succeed if grep fails and to fail if grep succeeds.
 This is the negation operator on shell commands.
 Now, in order to explain that,
 I need to talk about exit status
 and success.
 If you look inside a machine language program,
 something written in C++ and all that sort of thing,
 you'll see something that looks like this.
 Now, Larry Wall was a North Campus type.
 So linguistics background.
 And because he had a linguistics background,
 he was used to sort of thinking about natural languages
 like English.
 So the motto sort of,
 I'm not gonna tell you much about Perl code
 and all that sort of thing,
 but the motto of Perl was,
 there's more than one way to do it.
 And by that, he meant, in English,
 you often have multiple ways to say the same thing.
 And I want to mimic the flexibility
 and naturalness of English, right?
 So for example, in Perl, you can say,
 if X is less than Y, call F.
 You need more punctuation than this, but fine.
 It's sort of like that.
 Or you can say, call F if X is less than Y.
 Either notation works
 because either sentence works in English, right?
 And why should you be forced to say,
 and maybe inside here,
 you'll see a return 27,
 or maybe you'll see a return zero.
 Things in the wrong order in a programming language,
 in an order that's unnatural in English.
 And that just, that also, you know, he got steamed.
 Or you can even see an exit five, something like that.
 And any of these, at least if it's called from main,
 says basically, I want the program to terminate.
 And its exit status will tell the invoker
 whether this program was successful.
 By convention, exit status zero means success.
 And all other exit statuses mean failure.
 So it's like Tolstoy's comment about families, right?
 He once wrote, every happy family is alike,
 and every unhappy family is different, right?
 So in the operating system,
 every exit status of zero is the happy family,
 and then the unhappy families can exit
 with lots of different statuses.
 Yes, question.
 - So the integer that may return is the exit status.
 - Correct.
 For technical reasons,
 this integer has to be in the range zero through 255.
 You don't have a whole bunch of choices of exit statuses,
 but usually, I know when he saw it.
 So he added lots of different ways of doing it.
 Okay, Perl is still quite widely used,
 but it's safe to say that its heyday
 was in the 1980s and 1990s.
 It competed with a bunch of other scripting languages
 like PHP, and in some sense, won out over them, okay?
 And I wrote Perl code.
 I actually have published papers in computer science
 journals with Perl code in the appendix
 and all that sort of thing,
 'cause hey, I worked with a guy, why not, right?
 But there's a problem with Perl,
 and that problem basically boils down
 to its internal motivation.
 There's more than one way to do it.
 What that means is if you go read somebody's Perl code,
 you have to understand the way
 that person likes to write Perl, right?
 If they write it one way and you're used to the other way,
 you'll have to sort of contort your head around it.
 It's like if I listen to someone
 reciting poetry in Brooklyn,
 I have to sort of deal with a Brooklyn accent,
 and I can't make out half the words, all right?
 So it's fairly common to just basically exit status zero
 is success, exit status one is failure.
 There are some commands that have more than two exit statuses
 in particular grep.
 If you say grep x, exit status zero
 means it found an x, right?
 It means you successfully searched for x.
 Exit status one means you didn't find anything.
 And exit status two means you ran into some trouble.
 For example, you couldn't open a file
 that you were asked to read,
 so you don't know whether there's an x in there or not, right?
 Or maybe grep ran out of memory
 or something else bad happened, right?
 So some programs will have multiple exit statuses,
 different ways to fail.
 But cat, for example, it'll either exit with status zero
 or one, depending on whether it's success or failure.
 The shell cares about exit statuses a lot.
 The reason is because you're trying to figure out
 whether this command succeeded in your script
 before you can decide what to do next.
 So it's very common to see shell code
 that looks like this, right?
 If grep object at the center for something,
 something, something, this is Dutch and Amsterdam,
 the leading computer science Amsterdam, right?
 The leading computer science research institute
 in the Netherlands, right?
 And here was their problem.
 Their incoming students all knew basic
 because that's what they learned in high school.
 It's sort of like, you guys know Java or Python
 because that's what you studied in high school.
 But they didn't wanna teach in basic
 because basic is a terrible programming language, right?
 It's one of the world's worst.
 It's better than C++,
 but that's about all I can say about it, all right?
 So what they wanted to do was to encourage high schools
 in the Netherlands to have a decent programming language
 so that you didn't have to deal
 with the horrible features of basic, all right?
 So they came up with their own alternative for basic.
 And since it was a teaching language, it was called ABC,
 right?
 And this is, you know, 1980s, late 1980s,
 and that sort of thing.
 So the basic idea, excuse me, of AB--
 Eggert, et cetera, password, right?
 If Eggert's in the password file,
 then, you know, echo, okay, or something like that.
 Else, oh, you don't need a semicolon here.
 Echo, ouch, right?
 This is the shell way of doing if-then-else.
 We don't use the curly brackets of C
 for the then and the else parts.
 We just have keywords, if and then and else.
 There's a semicolon here.
 This is the way that I write it.
 If you don't like semicolons, you can say,
 put the then over here, it works either way.
 For this kind of thing to work,
 these four words have to be reserved
 because they're part of the control structure of the shell.
 They're not sort of individual commands.
 So among the reserved words of the shell
 are if-then, else, and fee, right?
 Fee is if backwards.
 You can think of this as being like an opening paren
 and this is like a closing paren.
 It's sort of backwards from the opening, right?
 And it's also short for finish, if you like.
 Yes?
 - Doesn't Eggert need to be surrounded?
 - See, it's as follows.
 First off, let's not force people to learn
 really low-level data structures like arrays
 and then teach them how to sort arrays
 and all that sort of thing.
 So idea number one of ABC is we want,
 of course we wanna have arrays,
 but we wanna have not just arrays.
 We wanna have things like sets and dictionaries
 and all that sort of thing.
 We want to sort of have high-level data structures.
 We don't want students to waste time
 learning how to do quicksort.
 I mean, what a waste of time.
 Just call the sort function, right?
 It already knows how to sort, right?
 That was their attitude.
 Second idea, they really hated grading student work
 written in BASIC because what the students would do
 is they would just write a bunch of stuff down.
 It would be so poorly formatted and indented.
 You couldn't even make out heads or tails of it, right?
 So they said, we're having to waste like two lectures.
 If the pattern is so simple
 that it doesn't have any shell meta characters in it,
 then you don't need to bother to quote it.
 Quoting won't hurt, but it's not necessary.
 That's true for every argument to every command, right?
 The reason I didn't have to quote et cetera password
 is because there's on how to properly indent.
 What a waste of time.
 We're going to have our programming language
 enforce good in no shell meta characters in here, right?
 Slash isn't a meta character and lowercase letters are not.
 All right, so if I had put this here,
 that's an exclamation point followed by a space,
 then I would have inverted the sense of the grep, right?
 Because that's sort of negating the sense of the grep
 and now we'll echo okay if I'm not in the password file
 and it will echo ouch if I'm in it.
 Question?
 - When do you use semicolon in shell tripping?
 - When do I use it?
 I use it when I want to put several commands
 on the same line.
 That's the only time you really need to use it.
 Here some people like, and in fact I kind of like,
 having sort of the then over here.
 But in order to do that, I'm going to need a semicolon here.
 If I left the semicolon out, indentation, right?
 So the second idea here was
 the ABC requires good indentation.
 If your program isn't properly indented,
 the ABC compiler would basically give you an F
 and not run your code, right?
 So they built something along these lines.
 The technology at the time was like,
 they had to use like stone knives and bear skins
 and floppy disks, right?
 And they sent out floppy disks to all the high schools
 in the Netherlands and had people try it out
 and what they found was the high school teachers
 had trouble learning ABC and the high school students said,
 why should we learn ABC?
 All the jobs ask for basic, right?
 So the project flopped and it would just be a footnote
 in computer science now except some of these researchers
 took this idea and said, we want to have the good stuff
 from this research project and we also want to take
 Perl as a negative advantage,
 a negative example I should say.
 We don't want this philosophy.
 We want to teach you how to program the right way, right?
 So what they came up with is called Python,
 named after Monty Python, if the story is to believe
 and just wrote then, then the shell would think,
 oh, I'm calling grep with three arguments,
 eggert, et cetera, password and then, right?
 In order to tell a shell, no, no, no,
 that's the end of the command.
 I have to put a semicolon here.
 So one way to put it is that in the shell,
 reserved words are recognized only at the start
 of a command.
 They're not sort of reserved words everywhere.
 They're only reserved at the start of the command
 and once you have a semicolon,
 then this is going to be the start of the new command
 and then it'll look at that,
 oh, this is the then keyword, it's reserved, yes.
 (muffled speaking)
 (muffled speaking)
 Oh yes, I should have been much more jumping up and down.
 So here, I'm going to jump up and down.
 Zero means true here.
 It's really counterintuitive
 but that's because we've decided zero means success.
 Success means, hey, it worked.
 In the shell, if it worked, that means we go,
 you know, work means successful, true, right?
 So a zero exit status to the shell means true.
 A non-zero exit status to the shell means false
 and this is true not just of the shell.
 It's true pretty much of any program has the motto,
 there's one good way to do it.
 Python does not follow this syntactic philosophy at all.
 It basically wants you to indent the right way.
 Perl doesn't care about indenting.
 You can do it any way you like
 but Python cares and so forth and so on.
 And one of the reasons Python has been successful
 in the last 20 years is because it's designed to be simple,
 easy to teach and there's only one way to do things
 which means when you read other people's Python code,
 you have a good chance of understanding it better
 than if you read other people's C++ or Perl code, all right?
 So that's kind of the motivation.
 Now, obviously there's a lot of details here.
 Any questions about the background?
 Yes.
 I cannot tell you.
 Well, I can tell you where we were.
 We were working in the offices
 of System Development Corporation
 which was the first software company
 ever to exist in the world.
 Founded a program that invokes any command.
 It'll treat zero as saying, "Hey, it worked, good, true."
 And non-zero is false.
 It's backwards of every place else in software construction.
 Sorry about that.
 Yes.
 Oh yeah, this acts like the exclamation point operator
 in C.
 So it turns any non-zero exit status into zero
 and it turns a zero exit status into one.
 All right?
 So I guess that means I should, you know,
 I'll list exclamation point as one of my reserved words
 because it is, it's used by the show.
 All right, let's try some more.
 There's also the case statement.
 If you're used to C++, it's a little backwards.
 You start the case statement with case
 and you end it with the wonderful keyword ESEC
 which is case backwards.
 It's following the same pattern.
 It's sort of like an opening paren and a closing paren.
 And the thing that you're casing on has to be a string.
 So for example, in '55, the first pure software company
 and we were doing, what can I say?
 I was doing theorem proving, I can say that.
 We were doing research for the government.
 How's that?
 How does that sound?
 Good enough?
 All right, the armed guards, yes.
 They were for real, yes.
 A wall was not paid to do this, not at all.
 He was paid to do other stuff.
 This was a side gig for him.
 And yeah, I mean, you know, eventually he quit SDC
 and he wrote a book and all that sort of thing,
 but no, he didn't do this for money.
 You're not gonna get rich doing this, trust me.
 All right, other comments on the background.
 All right, so let's see, I guess I've talked about,
 all right, we can talk about quick things
 about Python syntax, why not?
 (typing)
 So those of you expert in Python will probably think,
 oh, well, we can go to sleep now.
 I'll try to keep you awake.
 First off, you don't need semicolons.
 Semicolons are for wimps, right?
 You just, if you have three statements,
 just write three lines.
 Now, occasionally you can write something
 that looks like this.
 (typing)
 Case dollar sign file here.
 I'm assuming file is a shell variable
 that contains a file name in,
 and then your patterns are gonna look like this.
 That's the pattern that matches any file name ending in C.
 And here you can say something like echo C source, right?
 Two semicolons here at the end of the case.
 And over here you can say star dot H, echo C header.
 And then this pattern matches anything, right?
 So you can say echo something else.
 (typing)
 For whatever reason,
 you might want to put three statements on the same line.
 In that case, you can use semicolon,
 but normally you don't need them, ESEC.
 So you commonly use the case statement
 as a pattern match on shell variables,
 or this could be, you know,
 this could be one of the arguments to your script
 and that sort of thing.
 And you want to do something different
 depending on what that string looks like.
 The patterns here are, right?
 So that's one thing.
 And that's designed to make it easier to teach
 and all that sort of thing
 because they didn't want to waste their time
 teaching students about semicolons.
 We use indentation instead of curly braces.
 So no curly braces.
 So you write something like this.
 If X is less than Y, you gotta put a colon here,
 otherwise it's not right.
 And the rule is constructs that have sub-statements
 have colon at the end of the line,
 and then you indent as much as you like,
 but you have to indent consistently.
 I like two spaces, some people like four,
 some people like eight.
 Try to be consistent, right?
 And then here you can say A equals B and C equals D
 and print X and all that sort of thing.
 And you saw me do it in the example code
 where I would write a for loop
 and there'd be a colon at the end,
 and then I would indent a little bit
 before I typed the next line.
 I was doing that indentation.
 Yeah?
 - So if you indent two form spaces,
 you have to indent two spaces for every single--
 - That's the idea.
 Actually, what happens if you don't?
 Let's try it, right?
 For I in,
 do we have LS, right?
 Our globbing patterns.
 So they work the same way that, you know,
 star matches file names, except here,
 this doesn't necessarily have to be a file name,
 it's just a string,
 and we're doing a string pattern matching.
 Question?
 - Is the word in always used for--
 - Yes, there's always the word in here.
 It's not exactly a reserved word,
 it's kind of a noise word, but it's gotta be there.
 Question?
 Why do I what?
 I'm sorry, I still couldn't hear.
 Oh, because we need to know the difference.
 It could be that something,
 and you'll do several lines in here, right?
 You can say echo C header,
 and then you can say, I don't know,
 we can say print I,
 and then we can say print,
 okay, ouch.
 And it says, nope, I'm sorry, you can't do that.
 Now, there is an issue with indentation.
 If you type a tab character,
 how much indentation is that?
 The long-standing tradition in Unix and Linux
 is tab stops are every eight characters.
 The long-standing tradition elsewhere
 is FCO, mistake, and then two semicolons, right?
 So you can put several statements
 separated by semicolons in a single case.
 You know the case is over when you see
 two semicolons at the end.
 Yes?
 Yeah, this says echo C source.
 That runs the command echo C source, right?
 I can run it here.
 Echo C source, right?
 Which just takes its arguments and prints them out.
 It's not doing it, right?
 So you can do semicolons instead.
 So I could have written it this way.
 If X is less than Y, A equals B, C equals D.
 So if you want to,
 you don't have to put the stuff down here.
 You can put it after the colon.
 I suggest not using this style at least at first.
 You know, just use the standard style.
 I mean, this can be helpful sometimes
 if there's anything special here.
 Okay, other questions about the case statement?
 Yes?
 Oh, the shell is sort of like C with respect to indentation.
 It's optional.
 You don't have to indent if you don't want to,
 but it's a good idea.
 I usually maybe indent one or two spaces here.
 You don't have to indent at all.
 It kind of lines up either way.
 It's a style thing.
 Other questions about case?
 In back, please.
 If you like.
 Yeah, all of this stuff could be on one line.
 I don't recommend it though.
 It is really cramped otherwise,
 but otherwise I wouldn't bother with it.
 Character strings in Python look like this
 or like this.
 You get your choice as to whether
 you're going to use apostrophe or double quote,
 and in some sense it kind of doesn't matter.
 No, please don't.
 Yeah, don't do that.
 Oh, that would look ugly, all right.
 One more, yes, about case.
 These parens are not required.
 They're optional.
 You can write it this way, and it'll still work.
 It's perfectly portable, and some people prefer this style.
 I find though that when I write this style,
 my text editor gets confused
 'cause the parens don't match, and I use Emacs,
 and I love matching parentheses for reasons.
 You can tell Python was designed in the Netherlands
 where they're halfway between people that like double quotes
 and halfway between people who like single quotes,
 but there are a few other little goodies
 about character strings which you really gotta know.
 If you're gonna be reading a bunch of other people's code.
 First thing, you can put new lines in character strings
 simply by typing return as long as
 you write the character string this way.
 This is three single quotes right next to each other,
 and then you can say this is a long string,
 and it ends when you type three apostrophes
 right next to each other, right?
 So I can do something like this.
 SSS equals, right?
 I think I can even do this, right?
 And then SSS is, we describe later,
 so I tend to prefer the parentheses.
 You can write it either way.
 Also, you can put multiple patterns if you like in here
 separated by or, so you can say something like this,
 star dot CC, and then say echo,
 and then say C or C++ or something like that.
 So you can put in multiple patterns here,
 and that's fairly common as well.
 Question.
 - So is it usually the process that you reverse
 the spelling of the special command like if?
 - If and fee and case and ESAC are the only examples
 where they did the backward thing.
 It was Steve Born having fun having too much beer
 back in 1976 or something.
 Yes?
 (muffled speaking)
 No, it doesn't have that horrible misfeature of C++.
 What a disaster that is.
 They should take that feature of the language out
 and shoot it, and Steve Born said,
 we're not gonna do that in the show.
 All right, let's try a loop, okay?
 So the next thing we can do,
 I could've written it this way with backslash N in it
 and all that sort of thing, but you don't have to.
 You can just have an actual new line there,
 and this sort of here,
 is we can write a loop to iterate through things.
 So here's a fairly common loop of convention
 is used commonly when you're printing out a long message
 or that sort of thing.
 Double quotes are the same way.
 You have three double quotes right next to each other.
 You're starting off a long string
 that can cross line boundaries and the string ends
 when you have three double quotes again.
 There are also times when you may have a long string
 that has a lot of backslashes or special characters in them.
 You can write it this way if you like, all right?
 You can say A, backslash B, backslash, backslash,
 C, D, one, two, three, four, five, six, seven.
 All right, you can do it that way if you want,
 but instead, you can do it this way.
 And what did I do wrong?
 Unterminated.
 For F in dot F, right?
 Do, done.
 And what could we do here?
 We could say, I don't know, sort F, something like that.
 All right?
 This, well, let's try that again.
 A backslash, A backslash B, backslash, so I have C.
 Let's try that again.
 This iterates through everything, you know, after the end.
 This can contain as many words as you like.
 If this is in a script,
 here's one word per argument of the script.
 And what we're doing here is we're saying,
 for each sort of argument of the script,
 run the command sort and give it that string
 as the argument to sort, all right?
 Notice that this differs from this.
 (keyboard clacking)
 This says run sort once and give it N arguments.
 So it's going to read N arguments
 and give you the sorted output
 of all the files that it sees.
 This says run sort N times, one for each input argument.
 So the output of this for loop won't be sorted, right?
 Each individual file will be sorted,
 but it'll be the concatenation of the sorts
 of those individual files.
 So the resulting concatenation may not be sorted.
 Like that, right?
 So notice what happened here.
 A raw string does not have character escapes triads.
 - So is the quotation mark speller sign add?
 Is that a, like an array quote?
 - The shell, the standard shell needed in it.
 So that first backslash between the A and the B
 is just one backslash.
 And then there's two backslashes between B and C.
 It's not an escaped backslash.
 And you can see that in the resulting string
 that got printed out.
 Python normally prints out cooked strings, not raw strings.
 And in the cooked string, you have to put two backslashes
 where you want one backslash,
 and you need four when you want to.
 All right, any questions about raw versus cooked strings?
 This is all quoting, but you gotta get quoting right.
 Yes.
 (student speaking off mic)
 Well, so let's put it this way.
 If I type this, A backslash B,
 that's the same as typing this.
 Does not have arrays.
 It has only strings.
 And that's kind of annoying, but there it is.
 So this is a funny construct that expands to,
 those two strings are the same string.
 It's just different notations for the same string.
 So putting R, jamming R right in front of a string says,
 please don't interpret backslashes here.
 I just want the characters as is.
 (student speaking off mic)
 No, zero or more strings, zero or more words.
 It's kind of a special case.
 Question.
 (student speaking off mic)
 It takes all of the words that were given
 to your shell script, all of the arguments.
 Let's say there's five arguments.
 And it says, okay, I'll put them here.
 There'll be five arguments here
 if your shell command was invoked with five arguments.
 And it's not going to do any further splitting on them
 or any processing of it.
 It'll just give you exactly the arguments that you got.
 I guess one thing I forgot to mention.
 Well, in that last line that I typed,
 I typed two ends in A backslash backslash B.
 There, one backslash with if and with case and with for
 is that these commands nest.
 So for example, escapes the other one.
 Right, so both of those strings are three character strings.
 Question.
 (student speaking off mic)
 Because, well, Python's convention
 is that putting R right in front of a string
 means I can do something like this.
 I can take the I don't want.
 Well, let's try two of them, right?
 If I type this,
 then I'm, that's, I just typed in something
 that caused Python to compute a four character string.
 That string has A, then backslash,
 then this mean backslash, then B.
 And it printed out that four character string
 using this apostrophe A four slashes and B apostrophe.
 You read that and you say,
 oh, that's a four character string.
 (student speaking off mic)
 So R in front of a string just changes
 how Python interpreter reads that quoted string
 in order for it to figure out
 what string we're talking about.
 Yes.
 (student speaking off mic)
 Well, the raw notation is just a notation
 for entering the strings.
 Take the entire case statement,
 all the stuff that's running in it,
 and run it in an environment in which standard error
 is sent to the file ERR, right?
 And it works in both directions, right?
 That is, you can pipe stuff into a case statement.
 You can pipe stuff into an if statement.
 And that's not rare, it's fairly common.
 Everything nests nicely.
 Yes, in back.
 (student speaking off mic)
 Between the first which?
 (student speaking off mic)
 Right, so suppose we have two input files, A and B,
 and suppose A contains the contents,
 I don't know, IZ, we're not there yet,
 and B contains the contents, I don't know, Q,
 and then A, right?
 What this command will do is it will,
 if you give sort several files as input,
 it reads all the files, sorts what it has,
 and then outputs string, right?
 Once you have the string, it's not raw or cooked.
 Raw is just part of the syntax.
 It's not part of the actual objects that you create.
 Once you have the string, it's just a string.
 This command, however, ignoring the tack part,
 is gonna run sort twice.
 Once on, yes.
 (student speaking off mic)
 It normally prints strings in cooked form
 using a cooked syntax, yes.
 Yes.
 (student speaking off mic)
 (student speaking off mic)
 What other escape is, I think--
 (student speaking off mic)
 Oh yeah, yeah, so if we did something like
 R backslash A backslash N B, right?
 That's simply an A followed by a backslash
 followed by an N, all the backslashes
 turn into ordinary characters.
 All right.
 Other questions about strings?
 One other thing I should mention about strings
 is that there's a fairly handy operator called percent.
 Now, when you apply it to numbers,
 it works like percent does in C, right?
 100 remainder nine is going to give you one, right?
 Because you divide 100 by nine,
 you get 11 with a remainder of one.
 But our first file, and sorting that,
 will output IZ, and once on the second file,
 and sorting that, will output AQ, right?
 Every individual component of the output is sorted,
 but the resulting output is not sorted, right?
 So it has a different meaning.
 Yes.
 (student speaking off mic)
 This thing here, this has to be an identifier.
 And then the identifier is set to each word in order, right,
 in the body of the loop.
 All right, question.
 (student speaking off mic)
 Right, in this case.
 Question.
 (student speaking off mic)
 You can put, yeah, you can put whatever shell commands
 you like inside the loop,
 and they'll be executed.
 It also applies to strings this way.
 You can think of it as doing like what printf does in C.
 So you can say D once for each iteration of the loop.
 Question.
 (student speaking off mic)
 Oh, if I leave the dollar sign out,
 then this is just at, there's nothing special here.
 So this will, this loop will execute just once.
 F will be C, and then S and G, right?
 So these are the three printf formats,
 and you can apply this printf format to the tuple,
 45, and goog, and 19.27, let's say.
 And it returns the string, which is the result
 that you would have gotten if you used printf
 with that string format,
 and then these extra trailing arguments.
 So the percent operator can be very helpful
 for generating formatted strings,
 and then you can print them out later if you want.
 All right, question.
 (student speaking off mic)
 It'll normally print in cooked format, yes.
 (student speaking off mic)
 Well, first off, your decision to use a single quote
 to the character string at sign,
 so we'll try to sort a file whose name is at sign,
 which is probably not what we want.
 Question.
 (student speaking off mic)
 Explain the which?
 (student speaking off mic)
 Oh, yes.
 So remember last time, you can say something like this,
 echo foo two greater than error.
 This means send standard output of this command,
 I'm sorry, standard error,
 that's file descriptor two of this command,
 to the file ERR.
 That's all I'm doing here, except here,
 I'm saying I want that to be for the entire case statement.
 That means all these subsidiary commands
 are run in an environment
 where standard error is being sent to ERR.
 And so it's easier to write it this way.
 I mean, I could have put two greater than error
 to here and here and here,
 but it's easier to just do it once.
 Question.
 (student speaking off mic)
 The key word done is,
 I suppose this should have been spelled OD, odd,
 but that was just too odd for people.
 So a double quote doesn't affect
 whether the result is a string or not.
 It's gonna be a string either way.
 And once you have a string,
 it doesn't matter whether you typed it raw, cooked,
 or with single quote or double quote.
 It's still, Steve Bourne decided to spell it as done.
 It's the end of the for loop.
 Yes.
 (student speaking off mic)
 The same string with the same character thing.
 So the fact that I used single quotes here
 doesn't affect what string I got.
 But what happened was is I applied the percent operator.
 It's a binary operator.
 It's left operand is a format,
 and it's right operand is the stuff you want formatted.
 In this case, it's a triple,
 containing the three arguments
 that the format string refers to.
 (student speaking off mic)
 It'll always be a string.
 The result of a percent used this way is always a string.
 Question.
 (student speaking off mic)
 Am I going to require you to memorize
 all the format specifiers?
 No, no, plus it's an open book exam.
 So you can just print out the manual, right?
 It'll be all right.
 Okay, other questions?
 Yes.
 (student speaking off mic)
 R with a backslash at the end.
 (student speaking off mic)
 So R, it's sent to a file?
 Oh, because later on you want to sort of
 do some further processing on the file,
 or maybe the guy likes his error messages in a file
 rather than on a screen.
 It's totally up to whoever wrote the script.
 (student speaking off mic)
 This just arranges for error messages to be sent to air.
 It does not affect standard output.
 We could also put standard output.
 Oh, I see.
 Oh, well, these echo statements,
 they're going to be sending it to standard output.
 You're right.
 Probably makes more sense to do that.
 Okay, other comments?
 Let's, oh, yes, in back.
 (student speaking off mic)
 Can we, you'd like to put like a line
 between each component or something?
 (student speaking off mic)
 Can you modify a shell script while it's running?
 Oh, that's a tricky one.
 The short answer is don't do that.
 If you try to modify an executable in Linux
 while it's running, it depends on the kernel, I think.
 Some kernels will let you do it, others won't.
 It's a dangerous thing to do, obviously.
 The idea of having code that changes as you execute it
 should send shivers down your spine, right?
 Because that's, I think there's a special case
 for something like this.
 It doesn't like it.
 Let's see what happens.
 Enter, right?
 It says, "unterminated string literal."
 And why is that unterminated?
 Let's try this.
 (student speaking off mic)
 So even in a raw string, you can quote the character
 that starts the string.
 So that's kind of an exception
 to the general rule for raw string.
 So that backslash prevented the raw string from ending
 even though it was also part of the raw string,
 sort of a special case.
 Okay, why don't we take a break,
 and we'll start up again at roughly the hour.
 All right, let's start up again.
 So in Python, you compute with values,
 and every Python, attackers love to have programs
 that do that because it gives them
 a much bigger attack surface.
 So fundamentally, the rule is if you like edit the script
 while it's running, who knows what's gonna happen.
 Don't do that.
 In practice, the shell might've read the first half
 of the script from the--
 Python value is an object.
 It's an object-oriented language in that sense.
 So even if I type, I don't know,
 old version of your program, and the second half
 from the new version of your program
 and glued them together, and then who knows what it'll do.
 So try to avoid that.
 Yes?
 (student speaks off mic)
 Well, will this be on the exam?
 The answer to that question in this class
 is always correct, all right?
 Other comments?
 Just as an aside, here's one method I use
 to come up with exam questions.
 This lecture, like all the lectures are being recorded.
 I have a random number generator that I keep secret.
 I pick a spot at random in one of the lectures
 and say, "Oh, that was a cool thing I said,"
 and I ask a question about it.
 Except usually I have to do it twice
 because I wanna ask a single question
 that covers multiple topics, right?
 So if I've said it, it's on the exam, maybe.
 Question?
 Oh, one, right, or 11, right?
 That's an object.
 It happens to be an integer and all that sort of thing,
 all right?
 So each object
 has three things.
 First off, it has an identity.
 An identity is a unique value.
 Every object has its own identity,
 and you can test, you can find out the identity
 of an object by calling the built-in function id.
 So id of any object, right?
 So here we go, hello.
 Well, all right, I didn't spell hello right,
 but whatever, right?
 There's its identity.
 It's a big integer.
 One way to think about it, if you're used to C++,
 is that the identity of an object
 is that object's machine address.
 We are running on a machine where the addresses
 can get kind of big, but that's all right, okay?
 And if I ask some other string, hey, what's your identity?
 It'll give me a different address.
 - Sorry, I have one more question on the app.
 So say if you input multiple arguments,
 how does it then resolve into like,
 like say five different arguments
 instead of like five strings, four strings?
 - Well, so if I invoke foo this way,
 (keyboard clicking)
 that's right, because it has to be a different object.
 Now, notice if we do something like this,
 what it's going to do is it's going to find every file
 whose name starts with C and ends with D.
 This might generate three arguments, let's say,
 and then it'll give foo one, two, three, four, five,
 six arguments, all right?
 And so dollar sign, at sign, inside double quotes
 will expand into six separate words, yes?
 - You mentioned earlier as a shell
 that we can also call functions that have variables.
 - Yes.
 - Show us an example of that, like for the for loop,
 F is an identifier, but is that initializing a variable
 in the for loop?
 - Each time the loop body is executed,
 F is set to the next word in this list.
 I haven't got to shell functions yet.
 I think we ought to take a break before we get there,
 all right?
 So let's start up again in seven minutes.
 We're talking again, we have another announcement.
 Sorry about that.
 - Okay, hi everyone, my name is Celia,
 I have a quick announcement.
 ACM ICPC is running interview track this quarter.
 - We have two strings with the same value,
 they're both SSSS, but they have different identities.
 And if you're used to C++, you can say,
 oh yeah, that's reasonable.
 We have two different pieces of memory,
 and the first SSSS is stored in the first piece of memory,
 and the second one is stored in the second one.
 Question?
 - So when we do ID on a variable that we haven't initialized,
 we initialize it, and then we return its machine address?
 - Well, let's take a variable here
 that I haven't mentioned before.
 It'll say, there's no variable by this name.
 But if I assign something to this variable,
 then I can ask,
 and I will find out its identity.
 I'll find out the identity of the string that I created
 by saying X, Y, Z.
 Yes?
 - Why is the first one taking the ID
 below the same ID as the second ID?
 - Oh, that's very good.
 Oh, I didn't expect that.
 Oh, that's very cool.
 How did that happen?
 Any suggestions?
 - And we're having our first workshop
 on dynamic programming tomorrow,
 six to eight p.m. in engineering six to 89.
 So once again, six to eight p.m. tomorrow on Thursdays,
 engineering six to 89.
 Thank you.
 - Thanks.
 - Is it okay if I write it somewhere?
 - Yeah, how about if you write it here?
 And here you go.
 Okay.
 (people chattering)
 (paper rustling)
 (people chattering)
 (paper rustling)
 (paper rustling)
 (people chattering)
 (paper rustling)
 All right, sure.
 All right, let's start up again.
 There's another kind of loop in the shell
 that looks like this.
 Because I said no two objects have the same identity, right?
 And then yet there we see what seems to be two objects
 with the same identity.
 What happened?
 Correct.
 Python will delete objects if you don't need them anymore.
 And if all we did with that H-L-L-O string is ask,
 hey, what's your identity?
 Python noticed, oh, you don't need this string anymore.
 And it threw it away.
 And therefore, later on, when we allocated a new string,
 it just happened to have the same identity as the old one.
 Question.
 - Does this happen really often?
 - Yes.
 - Okay.
 - All right, Python is really good
 about finding unused objects and discarding them for you.
 You don't have to, there's no delete
 or free operation in Python.
 Delete and free are trouble, right?
 What happens in C++ when you delete an object
 and then try to use it later?
 Your program crashes if you're lucky.
 And if you're unlucky, it does completely bogus things.
 Python, that problem can't happen.
 Yes.
 Oh, correct.
 That is, this ID is valid only for...
 Let's write it this way.
 While s, do t, done.
 This is a while loop, and it keeps iterating
 as long as this statement succeeds, right?
 Every shell command has an exit status.
 It'll either succeed or fail.
 And so if this succeeds, it goes and does this statement,
 and then it loops around and comes again.
 If the statement fails, then it exits.
 These things all nest, so you can say something like this.
 While if, you know, I don't know,
 dollar sign one is equal to x,
 then cat a else sort b, phi, right?
 Else sort b phi, right?
 That's a long statement, right?
 And I could have put this on multiple lines if I wanted.
 And then here we can say, do something else.
 Sort q, done, right?
 So you can put as many things in s and t as you like.
 And so you can write, you know, fairly nice loops
 if you want to do that.
 There's also a variant of this,
 which I see rarely used, but I'll mention it.
 You can say until instead of while.
 That's the same as saying while not.
 For this program, and in fact, it's valid
 sort of kind of only for the current state of the program,
 right, 'cause the IDs could be reused.
 But yes, if I were to run the same Python again
 and give it exactly the same input,
 it might give me different IDs.
 That's perfectly allowed.
 Yes?
 - When I run an ID with like the same string
 over and over again, it gives me the same ID.
 But when you ran it, what, the two s's
 are giving you different IDs, it gives you different IDs?
 - Both answers are correct.
 - Is there no guarantee?
 - There's no guarantee, right?
 All you're guaranteed is that if you have two objects
 and they both exist, then they'll have different IDs.
 But if one doesn't exist anymore
 and you don't have fine-grained control
 over whether they exist, then, you know, watch out.
 All right?
 So every object has an identity.
 Every object also has a--
 I kind of think that's hard to read
 and I prefer the wild list.
 So you've got loops in the shell
 that look a lot like the loops in C++.
 Question.
 The type.
 And you can find out what the type of an object is
 by using the built-in function type.
 So we can say, oh, what's the type?
 Oh, let's go back down here.
 What's the type of A, B, C, D?
 Well, it's a string.
 What's the type of, I don't know, 11?
 It's an int.
 So you should be able to now tell me
 what will happen if I do this.
 - Is there a double equal sign?
 - This, there's spaces here.
 This is a command.
 There's a built-in command in the shell
 called open square brackets.
 And it takes a bunch of arguments
 and then it throws away the closed square bracket
 and it treats everything in the middle as an expression.
 And it uses single equals to stand for string comparison.
 All right?
 Other comments about this example?
 Yes.
 No.
 Yes.
 Yeah, the two bracket stuff I think is fancier
 and I'm not going to get into that.
 So single brackets I think are going to be tough enough.
 Yes.
 Oh, so dollar one is going to be the first argument
 of your command.
 And of course.
 The type of type is of course type.
 And you should also be able to tell me
 what happens if I do this.
 Right?
 Trust me, it all makes sense.
 It all hangs together, right?
 And now you should be able to tell me
 what will happen if I do id of type or type of id, right?
 Okay, so let's try a few other things.
 Oh, every object also has, I almost forgot this, a value.
 Right, so if you're used to C++,
 one way of thinking about it is the following.
 You can think of a Python object as being represented
 by a pointer to a piece of storage.
 This is the id.
 It's that big long in it.
 You can probably guess dollar two as the second argument
 and so forth and so on.
 And then dollar star stands for all the arguments.
 And it's got a, right?
 It's just a machine address.
 At the start of the machine representation of the object,
 there's a little flag that says hey, what's my type?
 This is the type field.
 It's a variant called dollar at sign,
 which means sort of the same thing,
 except if you have it in double quotes,
 it has that special meaning that we talked about.
 Yes.
 - Generally for C++, we use two equal signs,
 so like as a Boolean,
 but I see this only has one equal sign,
 so how do we do like a sign?
 - Oh, a variable assignment in the shell
 is you write the identifier, an equal sign,
 no spaces, and then a value.
 So this takes, this assigns the value v,
 just the character, a single character v string to s.
 So all shell variables are string variables.
 There are no other types in the shell.
 Everything's a string,
 and every assignment is a string assignment.
 Question.
 - The difference between comparing strings
 and assigning subs would be?
 - Context, and also you gotta put spaces
 around the equal sign here.
 But it's mostly context.
 Question.
 - Could you answer what that is?
 - This says, while this long if statement succeeds,
 do the sort.
 What does the if statement do?
 It says, if this string is equal,
 all right, that way the interpreter,
 when it's handed some random objects
 from someone ever can go look at the type field
 and figure out what the type of the object is.
 And then the interesting part of the object is over here.
 It's the value, all right?
 So a string object is represented like this.
 When this first part says, I'm a string,
 and then this is H-E-L-L-O, new line,
 or something like that, right?
 Now, once you have this idea,
 a lot of things about Python become easier,
 but there's one thing I should mention.
 These two things never change.
 Once you have an object, its ID is not gonna change.
 Well, maybe the object will go away, but all right.
 But as long as the object's around,
 its identity will be the same,
 and its type will be the same, right?
 The Python terminology for this sort of thing
 is it's immutable, right?
 It's unchangeable.
 The value of the object, however, might be mutable,
 and it might not be, right?
 So this one is a little special, right?
 This can be, well, the contents of the, you know,
 the first argument is just the string X.
 Then run the command cat a.
 Otherwise, run this command sort b.
 If cat a fails, you exit the loop.
 If you get to the sort b instead and it fails,
 you exit the loop.
 But if these guys succeed, which they probably will,
 you're going to loop.
 Why would cat fail?
 Well, it might fail if the file a doesn't exist.
 Or you might loop around several times.
 In the meantime, somebody else removed the file a,
 and then cat starts failing, right?
 So that would be, I mean, this is kind of a weird example.
 I just made it up.
 It's not very practical.
 There's another reason cat might fail,
 which is something like this, et cetera.
 Password, immutable.
 (typing)
 And it can be mutable.
 Whether it's immutable depends on the type.
 And send the output to dev full.
 Dev full is a special file that type.
 Lists are mutable.
 If you have a list, you can go change its value.
 Strings, it's always out of space.
 It's full.
 You can't output anything to it, right?
 If you output just a single byte, dev are immutable.
 If you have a string, you cannot go
 and edit the contents of a string, right?
 So this would be string, and this would be full.
 We'll say, I'm sorry, there's no room here, right?
 So if I run cat dev, et cetera, password dev,
 I'll get an error message.
 And it would be list.
 Ints are immutable.
 If you have an integer 27, there it is, it's 27.
 You can't change it to be 28.
 It's always gonna be 27.
 Now you may be thinking, wait a second.
 If that's true, how can I do something like this, right?
 I'm going to set i to be 27.
 And now I'm going to set i to be i plus one.
 Haven't I changed that integer to be 28?
 And the answer is no.
 That 27 is still 27.
 All you've done by this assignment statement,
 i equals i plus one, is you've computed a new object, 28,
 and you've assigned that object,
 that reference to that new object to i.
 This is the standard way many, in fact,
 I would say most scripting languages work.
 They're object-oriented, and this is how they act.
 This is how elist works, too.
 I just didn't go into this much detail.
 So it's a different feel from C++.
 Any questions about the basic, the exit status,
 which is always in the special variable question mark,
 will be non-zero.
 That cat failed, right?
 Because it couldn't write to dev full.
 Yes.
 - With the wild loop, how do we iterate?
 How do we change the check again?
 We check our first argument,
 but then do we go to the second argument,
 or is our first argument going to change anyway?
 - Oh, like if you wanted this to,
 if you wanted to iterate through the arguments.
 - Like, what I'm basically saying is,
 how is this loop finite?
 - How is it, oh, well, yeah.
 So it would be finite if somebody else removed a, right?
 Then, otherwise it'll keep going.
 Yeah, it's not a particularly useful one.
 You would probably write something more interesting here.
 You would use a shell variable
 that's contents change in the body of the loop.
 Yes.
 - Does if have an exit status?
 - The exit status of an if is the exit status
 of its then part or its else part, whichever got executed.
 - What about the if the,
 the expression evaluated by the if statement?
 - Then you go and execute the else part
 and you see what it exits, exits with, right?
 By the way, this idea of using if as an expression
 is very common.
 You've seen it in C++, right?
 In C++, you can write component here of Python.
 Yes.
 - So what is C++ doing in this position?
 - What does C++ do?
 Well, I'm the worst person to ask about C++
 because the last time I wrote C++ code
 was in 1992 and I ran away something like this.
 This is an if expression.
 You evaluate A, if it's true, you evaluate B,
 yield whatever it yields and otherwise from its screaming.
 It was the worst software project I've ever done
 in commercial life, right?
 So, but C, you can ask me about C, all right?
 So in C, typically, you just create stuff
 and you can go scribble over it all that you want to.
 There are a few exceptions.
 You can create constant objects in C that are immutable,
 but if you're at the C level,
 you can go and scribble on this and there's not a problem.
 Also with C, you can see the point you evaluate C.
 Same thing's happening here.
 C++ also has this notion, right?
 Which in C++ is equivalent to this, right?
 B, else, zero, they mean the same thing.
 Similarly, the shell has this notation.
 In the shell, this is equivalent to if A,
 then B, else, false.
 False is a built-in shell command that always fails.
 It always has non-zero exit status.
 So you can write short hands like this in the shell,
 just like you can in C++.
 And you can probably guess what this means.
 This means run the command A.
 If it succeeds, you're done.
 If it fails, run the command B
 and then yield whatever B's exit status is.
 Yes?
 (man speaking off mic)
 Yeah, one of these things has to fail.
 Either the cat has to fail or the sword has to fail.
 Otherwise, this loop will keep going.
 Yeah, sure, right?
 You have values of type char star
 that are distinct from the strings that they point at.
 You don't see that in Python.
 In Python, there are no pointers in Python.
 All you see are objects.
 This is the way they're implemented internally,
 but you never see the pointers to them.
 Yes?
 (woman speaking off mic)
 Correct, absolutely, right?
 And Python actually internally has efficient ways
 to represent small integers,
 so it's cheaper than it might sound.
 But in principle, you're creating a new object.
 Yes?
 (man speaking off mic)
 In Python, you pass objects to functions,
 and I guess from a C or C++ point of view,
 that means you're passing everything by reference,
 but you don't see the references in Python,
 so it doesn't matter.
 Yes?
 (man speaking off mic)
 Yeah, I just spelt it out the long way.
 It's the same basic idea.
 Question?
 (man speaking off mic)
 Well, you can think of--
 (man speaking off mic)
 That's dollar sign question mark is the exit status
 of the last command.
 The identity is being like the address of an object
 in C or C++.
 The difference is that once you have the identity,
 it's an integer, and that's all you can do with it.
 You can print it out.
 You can compare it to other integers.
 You can do arithmetic with it,
 but you can't go from that integer back to the storage
 that it's pointing to.
 You can't--
 (man speaking off mic)
 (keyboard clacking)
 Okay.
 Other questions or comments about these shell constructs?
 All right.
 (man speaking off mic)
 I referenced the integer.
 So that's why ID, which sort of acts like, you know,
 convert a char star to an int and that sort of thing,
 so it's a low-level operation.
 It acts like that.
 I guess I should talk more about variables.
 Well, we've talked about most of them already.
 Let's do a few more.
 Dollar sign, sharp sign expands
 to the number of arguments that you have.
 You can use it in a shell command to make sure
 that you got past the proper number of arguments.
 Dollar sign zero expands to your zeroth argument,
 which by convention in Linux is the name
 of the command, all right?
 So this is your command name.
 So this is how a script can find out its own name.
 It just used dollar sign zero.
 You commonly see that used in diagnostics.
 You'll see something, but it's not dangerous
 the way it is in C++.
 In C++, if you screw up with pointers,
 your program will crash or do weird stuff here.
 You can't crash because you can't get at the pointer.
 All you can do is print it out, all right?
 Other comments about this core stuff?
 All right, so let's see what we have else.
 Oh, also associated with objects,
 all right, every, like this, echo dollar sign zero,
 missing argument, something like this,
 and send that to standard error.
 All right, so that's kind of a standard thing
 you might see in the shell.
 A diagnostic send to standard error,
 but you say the name of the command
 so that the user knows where it came from.
 There's a bunch of other sort of things
 you can do with variables.
 So to some extent, let's talk about variable expansion.
 And by variable expansion, I mean,
 if you want to refer to the contents of a variable
 or to see whether a variable has been set or not,
 use different syntaxes to do that.
 The simplest one, of course, is you do this.
 Object has this, but most objects have something else.
 They have attributes.
 (keyboard clacking)
 If you have an object O,
 then you can find out what the value of its attribute
 called A is by using this notation.
 This says, give me the attribute named A of the object O.
 You can print it out and you can also assign to it.
 You can say something like that.
 This says, take the object O and make its A attribute
 to be 27, right?
 This expands to the value of the variable XYZ.
 If XYZ hasn't been set, it's an uninitialized variable.
 You've never talked about it before.
 That expands to the empty string.
 It's not an error.
 The shell is very forgiving there,
 maybe a little bit too forgiving.
 Now, you can do something like this.
 Most objects also have methods.
 If you have an object O and you want to call a method
 on behalf of that object, you do something like this.
 This means call the method M for the object O
 and give that method.
 This expands to the variable,
 the contents of the variable XYZ, if it sets.
 And if XYZ has never been set, it's uninitialized,
 it expands to this string, D-E-F-A-U-L-T.
 You can put any string here you like, right?
 So this way you can provide a default value for a variable
 that's not the empty string, right?
 In some sense, this first notation here
 is equivalent to saying this,
 except this is a lot easier to read than this.
 They both mean the same thing.
 You can also say this.
 This expands to the string S-E-T if this variable is set
 and to the empty string otherwise.
 So you can use this to find out exactly
 whether the variable is set or not.
 You can also do this.
 (mumbles)
 This expands the value of X if it's set.
 If it's not set, it expands to this method,
 the arguments X and Y, okay?
 All right.
 So let's see if we can do a couple of string D-E-F-A-U-L-T.
 And as a side effect, it modifies X to be the default.
 So after you execute any command
 mentioning the variable this way, things here,
 I should mention a couple of standard sort of expressions.
 When you write this,
 is is an infix operator in Python
 and A is B is true when A and B are the same object, right?
 This can be arbitrary expressions, right?
 This could be something really long.
 Could be something really calm.
 But the point is we evaluate this expression,
 we evaluate this expression and A is B yields true
 if they're the same object and false otherwise, right?
 So we can do something like this, A-B-C-D, what's that?
 Oh, that's our string X-Y-Z.
 We can say A-B-C-D is A-B-C-D and that's gonna be true.
 Yes?
 - Is this the same as comparing their ID?
 - Correct, right?
 This is, you can think of it as shorthand
 for ID of X equal equal ID of Y, right?
 Conversely, you can write a complicated expression
 like this, right?
 And use equals equals and now it's complicated, okay?
 You know that X will have a value of some sort.
 This expands to the value of X-Y-Z if it's set
 and makes the shell error out otherwise, right?
 So you use this syntax if you don't like the idea
 that, you know, variables have default values,
 you just want it to be a mistake in your program,
 that sort of thing.
 This is the closest to the rule
 that you would get in C plus plus.
 Part of what's going on here is the shell is designed
 for informal programs where we want it to keep going
 when you make a dumb mistake and maybe it will guess right
 as to what you intended, right?
 In other words, it's not really intended
 for super reliable programs and that's sort
 of what I hope you're getting a sense for here.
 You can also do something like this.
 [ Typing ]
 This makes the value of X-Y-Z be unset.
 It's now initialized again.
 That's not something you can do in C plus plus
 but it's helpful in the shell.
 You can also do this command.
 [ Typing ]
 This compares the contents of the objects, not their addresses.
 That's a value comparison as opposed
 to being a reference comparison.
 Yes? This puts X-Y-Z into the environment.
 I'll put a little sort of thing up here, environment variables.
 >> Is there a way we, sorry, let me rephrase my question.
 Is there like a specific default integrator we have in Python
 or is it based on the object we're using?
 >> When you're comparing two objects?
 >> Or like, for example, when you talked about iterators earlier
 with our like zip object.
 The zip object has its own specific iterator object?
 >> Yes, it does, right?
 But that's going far beyond what we've been talking
 about here, yes?
 >> But you said no two objects have the same ID.
 >> Right.
 >> What's the point of having this stuff?
 >> Well, I just showed you how it could be true, right?
 So the point of having is, is you want to make sure
 that you have exactly the same object on both sides of the is
 because you're some method that gets called
 in some complicated way and you're worried
 that the two arguments happen to be the same object.
 And in that case, you want to act differently
 than if they're different objects.
 That would be the argument for is.
 Another argument for is, which is maybe less compelling, is.
 Associated with every process, that is,
 with every running command, there's an environment.
 That environment contains a bunch of environment variables
 that are basically name value pairs where the names
 and values are strings.
 You can see what your environment looks
 like by typing the built, the Linux command ENV.
 That just basically prints out all of the environment.
 I have a lot of stuff in my environment.
 Oh, my goodness.
 Let's see if we can be a shorter version of this.
 I'll pipe it into less.
 Oh, here we go.
 So, for example, in my environment,
 there's an environment variable named shell in all caps.
 And the value of that environment variable is user
 local CS bin bash because I'm using the bash that's there
 rather than the one that's in user bin.
 There's another environment variable called less.
 Its values are CI NSR because those are the default options I
 use when I run the less command and so forth and so on.
 All right?
 A very interesting environment variable is about halfway
 down the screen here.
 It's called PWD, and that's the name of the directory
 that I'm currently in.
 In some sense, the output of what PWD would print
 if I typed the PWD command.
 And so it's fast.
 Is is fast because it's just pointer comparison, right?
 It's a single machine instruction plus
 interpreter overhead.
 Equals equals is not necessarily fast.
 If you're comparing two really long strings, equals equals can
 take some time, right?
 So this is order one.
 This is order N. And for that reason, you might prefer
 to use is if you know is is all you need.
 All right, question?
 [ Inaudible ]
 Wait, you see you tried, you tried A is B?
 [ Inaudible ]
 All right?
 [ Inaudible ]
 Forth and so on.
 When you type export XYZ, you add it to your environment.
 So if I said something like this.
 [ Inaudible ]
 Oh, oh, how did that happen?
 Oh my goodness, yes?
 [ Inaudible ]
 They are the XYZ equals hello world.
 And then I type N and I grab for XYZ.
 Oh, I have to export it.
 And then we'll do that N again.
 We'll see that now any subcommand,
 we'll see that hello world is the value
 of this environment variable.
 Question?
 [ Inaudible ]
 It can affect your subsidiary programs in ways that you like.
 That's the basic idea here.
 You're configuring their environment.
 One environment variable I hope you already know
 about because it was an assignment one towards the
 start, all right?
 And I'll show you the value of my environment variable path.
 Or I guess I could just say, oh, I have a lot
 of path environment variables.
 Let's just look at dollar sign path, right?
 The path environment variable is a list of directories,
 directory names separated by colon.
 Whenever you type a command in the shell
 where the command name doesn't have a slash in it,
 it's just something like sort or cat name object,
 what Python has done is it's seen two instances
 of the same character literal and it's decided
 to use the same object for both, which it is allowed to do
 because it's a constant.
 And so it's doing constant sharing.
 Yes?
 [ Inaudible ]
 Yeah, the same sort of optimization can occur
 in C++, right?
 That is in C++ if you write this, or in C. Let's make it C
 even simpler.
 Whoops. And see this might return true
 and it might return false.
 It will return true if the compiler looks
 at these two constants and decides
 to allocate the same storage for both of them,
 which it can do, they're constants.
 It will return false if the compiler is lazy and doesn't do
 that and allocates two copies.
 Yes?
 [ Inaudible ]
 Because you can't trust the compiler to always do that
 and it could be something that you call read
 or something like that.
 It looks in all those directories to see, you know,
 is there one there called cat or sort or that sort of thing.
 So, for example, I could do something like this
 for D in echo path and then let's transliterate colon
 to space do LS minus L D cat done, right?
 So, what I'm doing here is I'm looking
 for every program named cat that's somewhere in my path, right?
 I'm taking the path, I'm turning all the colons to spaces,
 and then I'll iterate through all the resulting words
 that I get.
 And let's see what we got when we're done.
 We see there's no cat in the first directory.
 There is a cat in user local CS bin.
 That's the cat that I'm actually going to run when I say
 and it reads some string from a file or somewhere
 and it happens to be four A's.
 Will it then figure out that that's the same string
 that you already have somewhere else?
 Probably not.
 All right.
 Other question, yes?
 [ Inaudible ]
 Yes, cat. It's going to be user local CS bin cat,
 which is a symbolic link to some core utils five, nine, five cat.
 If user local CS bin --
 [ Inaudible ]
 You can say A bracket two.
 We haven't got to this yet, but all right.
 But can you say A bracket two equals X?
 The answer is no.
 Strings are immutable in Python.
 Yes?
 [ Inaudible ]
 That's right.
 It would have to be false because lists are mutable
 and you can't call us lists because they happen
 to be the same value now.
 Good comment.
 All right, any other comments on these examples?
 All right, so one reason Python won and Perl lost,
 and the other scripting languages have sort
 of lost is Python has a very good set of built-in data types.
 You can define your own, of course, but part of the motivation
 for Python, as I indicated earlier,
 if cat weren't there I'd eventually find the one
 in user bit.
 So path is a very important environment variable
 because you can use it to fiddle
 with your shell script's brains, all right?
 You've got this shell script that calls sort.
 It thinks it's sorting stuff, but you can put a sort
 at the start of your path that doesn't sort.
 Instead it, I don't know, shuffles instead.
 All of a sudden your shell script will do something
 completely different than what you thought it would do.
 And I hope that sort of impresses on you the importance
 of getting the path environment variable right
 and in general getting your environment variables right.
 They're important ways
 of making sure your programs do what you want them to do.
 All right, any questions on the environment variable,
 that sort of thing?
 Yes?
 [ Inaudible ]
 This does not affect the value of XYZ later.
 It just says use default now, but XYZ remains unset.
 This modifies, oh, I guess this should have been XYZ.
 This modifies XYZ to be this string default.
 So later on if you say dollar sign XYZ you'll get D-E-F-A-U-L-T.
 Here you wouldn't.
 If you later say XYZ you'll say, oh, it's the empty string again.
 [ Inaudible ]
 Where is the what defined?
 Is that they didn't want you to have to go through the hassle
 of defining all of your own types
 and implementing your own quicksort
 and all that sort of thing.
 What a wasted time.
 So all the standard sort of things that you might want
 to have in CS31 are already built in in Python, all right?
 So I'm going to take a quick tour through the Python types.
 There's too many to cover them all.
 But you should at least have a feeling for the overview
 of at least the basic types that are out there.
 The first type is the type of none, all right?
 All right, there is a special value in Python called none.
 And you can think of this as being sort
 of like the null pointer in C. So there's only one object
 of this type and it's none, right?
 It's the standard way in Python that you indicate
 that there's not anything there of interest.
 The second major category of data types
 in Python are numbers.
 There are several different kinds of numbers in Python.
 The ones that you tend to run into the most often are,
 of course, int and float.
 Float really corresponds more to what in C
 or C++ is called double, but it's floating point numbers.
 You also have Boolean.
 Why would you like to do this instead of this?
 Because you're trying to be very careful.
 You don't want to change any variables at all
 because you're trying to be, you don't want your script to sort
 of mess with the variables or that sort of thing.
 But you do want to have a default value that's not the
 empty string.
 In that case, you use this.
 Here, if this is a variable that you're in total control of it,
 you never want it to be empty, all that sort of thing,
 you'd probably use this flavor.
 Question?
 [ Inaudible ]
 All right, so here I used it.
 I said give me the value of abcdef.
 There isn't any such value.
 So it said, oh, well, then I'll just substitute that.
 And now notice if I now echo abcdef,
 there's still nothing there.
 I haven't set the variable.
 All right, so that's the difference between the minus sign
 and the equal sign.
 [ Inaudible ]
 Well, the hello thing, these are just strings here.
 I'm not actually running any commands here other than echo.
 So when you're talking about shell variables, your bool
 values, which are false and true, count as numbers.
 False counts as zero.
 True counts as one.
 So in that sense, bool is sort of like the Boolean data type
 of C or C++.
 We also have complex numbers, all right?
 So you can write something like 3 plus, I don't know, 9j.
 They use electrical engineering notation.
 That's a single number, 3 plus 9j.
 And if you -- all the electrical engineers
 in the audience will know exactly what it means, right?
 Okay. Any questions about numbers?
 Numbers are immutable,
 and they should be relatively straightforward.
 The next major category of types in Python are sequences.
 These are finite sequences of objects, okay?
 And some of the sequences are specialized.
 Some are more general.
 Some examples of sequence types
 that we've already seen are string.
 We're only talking about strings, right?
 You're not talking about commands in general.
 >> Yeah.
 >> Question.
 >> So what's special about the curly brackets here?
 >> The curly braces here are part of the --
 you say -- once you say dollar sign, open curly brace,
 you're using one of these syntaxes.
 And that's what curly brace means in this particular context.
 In other contexts, curly braces mean other --
 a completely different thing.
 >> So it doesn't mean it's variable expansion, like --
 >> Dollar sign in front of something kind
 of means a variable expansion, unless it's an opening paren.
 Yes?
 >> What's the locality of shell variables?
 >> Every shell script has its own set of shell variables.
 They start off being nothing there, right?
 Except it starts off with the environment set, right?
 It inherits the environment from its parent.
 Whenever you run a command, it starts off
 with the same environment that you had.
 And then it can start fiddling with its own environment.
 Question.
 >> Over again, what's the meaning of X, Y, Z plus itself?
 >> This expands to nothing if X, Y, Z is unset,
 and it expands to the string SET if it is set.
 It's an unusual combination.
 Yes?
 >> When a shell script modifies the environment, is that --
 >> Right. A string is a sequence of characters.
 There's no character type built into Python
 because we don't need one.
 Right? A string of length one is a perfectly good character.
 So you don't need a special type for character.
 It's just strings of length one.
 If you want to have strings of length one, go to it.
 All right?
 We also have lists.
 Strings are sequences where the components are all characters.
 Lists are sequences where the components can be whatever
 you want.
 There's no requirement in Python that every value
 in a list has to be the same type.
 In fact, the very first example I gave you of a list
 in Python was the one where we had an integer and a string
 and a float all in the same list.
 Right? So you don't have to worry about, you know,
 the lists all having to be homogeneous types.
 It modifies its own environment.
 The environment will be inherited, you know,
 by subcommands.
 They'll get a copy of that environment, and then they --
 We also have tuples.
 Tuples are a lot like lists,
 except they use a different syntax.
 You write a list this way.
 You write a tuple this way.
 And tuples are -- you can start fiddling with their copies,
 but it won't affect anybody else.
 Another question in front?
 No. All right.
 So let's do -- let's see, tilde expansion.
 Sure, why not?
 So, so far, we've talked about variable expansion.
 And in some sense, variable expansion, you can think of it
 as happening kind of first in your --
 well, first off, we do tokenization, right?
 Then we do variable expansion, and then after that,
 we do tilde expansion.
 And what that means is if the shell sees a word in your command
 that starts with a tilde, it treats that as either the name
 of your home directory, if it's just a plain tilde
 or a tilde falling -- followed by a slash, or if you see something
 that looks like this, it treats it as Eggert's home directory
 if you see a word that looks like this or maybe a word
 that looks like this, followed by a slash,
 followed by some other stuff, right?
 Mutable. Whereas lists are mutable.
 It's a big difference, okay?
 You can take a list.
 Tilde expansion occurs after variable expansion.
 So if you do something that looks like this, V equals tilde, right?
 If I now say, okay, what's V?
 Well, V is a tilde.
 You know, it looks like that.
 You can change elements in the list.
 You can grow the list.
 You can shrink the list.
 But in Tuple, it's stuck.
 Whatever it is, it is.
 You can't make it bigger.
 You can't make it smaller.
 You can't change any of its elements, right?
 The Tuple is what it is.
 Now, it could be that the Tuple contains an object,
 and that object itself is mutable.
 That's okay.
 But you can't change the fact
 that this Tuple contains that object.
 That part is immutable.
 Let's see, what else have we got?
 We have other types.
 I'll mention one other, buffers.
 A buffer is basically, it's like a string, but it's mutable, right?
 And you use buffers if you're not quite sure what string you want,
 and you can fool around with the buffer for a while, blah, blah, blah.
 And eventually, you can convert the buffer to a string pretty easily just
 by passing it to the string constructor.
 That's a fairly common pattern in Python.
 There are other sequence types, but that should give you a feeling
 for them, right?
 We did the variable expansion followed by the Tilde expansion.
 All right, next comes command substitution.
 We've already talked about that.
 That's if you have a construct that looks like this,
 someone in your script, or like this, although this is an uglier variant.
 This means run this as this command, take its output, treat it as a bunch
 of words, and then keep going.
 You do command substitution after you do all those other things, all right?
 The next one is arithmetic expansion.
 This uses this syntax, two parens instead of one.
 And what happens is inside here, you can say something like this,
 and all the identifiers you see inside these double parens are treated
 as names of shell variables.
 So this looks up the value of x, and it better be an integer.
 It subtracts one from the integer, and it expands
 to the string that's basically one less.
 Next major category are mappings.
 Mappings are, in some sense, they're like hash tables.
 Another way of thinking of a mapping is it's sort of like a sequence,
 except its indexes are not integers.
 They're whatever character string that you like.
 And the classic Python type that's a mapping is a dictionary,
 and I'll talk more about dictionaries later.
 Question?
 >> Is the buffer type in Python 3?
 >> Did they yank it?
 >> I think that's Python 2 only.
 >> Oh, shoot.
 That was one of my favorites.
 What did they replace it with?
 >> I don't know, I assume it's in Python 3.
 >> Oh, I liked buffer.
 All right, forget about buffer.
 I wasn't going to have you program it with it anyway.
 I mean, part of the problem here, though, is, you know,
 I mean, fundamentally, strings, you want to be able
 to mutate strings, right?
 So a common way to do that is you just have a list
 of characters than the string that x was.
 It's a simple way of doing arithmetic.
 I don't recommend it for high-performance arithmetic.
 I hardly ever use, you know, arithmetic expansion
 to be obvious, to be honest, because the shell really isn't
 designed to do arithmetic, and if you're doing arithmetic
 in it, you're using the wrong tool.
 After this, we do field splitting.
 The idea here is that if you look at the expansion
 of a variable, you can split it at this point.
 So, for example, if you do something like this,
 and then you do cat dollar sign v. The way the shell works is,
 first it does variable expansion, so this turns
 into cat a, b, c, right?
 And then it does field splitting.
 It takes these spaces and says, oh, well,
 we now have three words.
 So cat will now see three arguments, not one.
 Your source code, right, and you can mutate the list
 of characters on.
 The problem with having lists of characters is it's too slow,
 and that's why they used to have buffers in Python 2,
 and I guess they have something more complicated in Python 3.
 Yes?
 >> Can you explain what mappings are again?
 >> So mappings, how should I say it?
 You can think of sequences as being sort of functions
 from integers to objects, right?
 Mappings, file name, you know, v is a file name,
 but since v had spaces in it, the shell says, oh,
 we really meant to have three file names here
 and not just one file name, are functions that map
 from objects to objects.
 So they're like sequences, but instead of using integers
 to index them, you use arbitrary objects.
 But there's a, for dictionaries, which is the kind
 of mappings most people use, there's a strong rule about that,
 and we'll get to that later, these objects have
 to be immutable.
 So there are mappings from immutable objects
 to possibly mutable objects.
 If you don't want field splitting, you need to quote,
 right, if you do this, that's the equivalent of saying this.
 But oftentimes, and I'll talk more about the mappings later.
 Then the next major category
 of Python types are the callables.
 Callable values act like functions, right?
 So if you have a callable value f, the way, I mean,
 you can use it like any other object.
 You can stick it in a list.
 You can assign it to a variable.
 You do want to have multiple file names in the shell variable.
 In that case, field splitting is your friend.
 After we do field splitting, we do path name expansion,
 sometimes called globbing.
 Here, the shell looks for unquoted special characters
 in your words and uses them to pattern match off of file names.
 The special characters are as follows.
 Star matches zero or more characters, all that stuff.
 But the way you sort of put it into action is you call it
 and maybe give it some arguments,
 that sort of thing, right?
 So anything that can appear here
 in a Python expression is a callable.
 So obviously, examples of callables include functions.
 Question mark matches exactly one character.
 And the square bracket notation that you know and love
 from regular expressions also works here, right?
 It's like regular expressions.
 It matches one character and then methods, right?
 A function is like a function in C or C++.
 A method is a function that can be bound to an object
 and that you can then use this sort of syntax to call it.
 Here, we're calling this method, right?
 Method, left paren, a bunch of arguments.
 Classes. A class is a callable, right?
 So if I, I don't know, I already did that here, right?
 This means call the constructor for int,
 pass it this string as an -- ooh, that's not going to work.
 Pass it this string as its argument, and then the constructor
 for int will build you an int that happens
 to be the integer 392.
 So classes are callables.
 We have others, generators, and that sort of thing.
 There's lots more where this came from, but, you know,
 this is the basic idea.
 There are other forms of data types in Python,
 but these are the major categories that I'd
 like with one glitch.
 And the glitch is that instead of using this
 to mean negate the character set, the shell likes
 to use an exclamation point,
 and that's because the two committees couldn't agree.
 All right?
 So for example, we can say something like this
 to turn our attention to.
 So you know about none, or at least you know now,
 and you know numbers pretty well.
 You know how they work.
 What I'd like to next talk about is sequences, all right?
 And there's lots of different sequences,
 but sequences all can support a certain set of operations, all right?
 So here are the sequence operations.
 The simplest one is if you have any sequence S,
 you can index it, and sequences,
 since this is a computer science language,
 you start indexing them at zero, right?
 None of this start at one business.
 That's for North Campus wimps, right?
 We start sequences at zero, all right?
 So if you have a sequence of length N, right,
 here is the zeroth entry, the first entry.
 Here is the N minus first entry, all right?
 And S sub I yields the ith element of the sequence,
 but there's an extra little goody here that you don't get in C++, right?
 You're also allowed echo user bin question mark A through E,
 T through Z, right?
 And this is doing globbing.
 We're finding every command in user bin that has any character,
 I don't care what it is, followed by a character in the range A
 through E, followed by a character in the range T through Z.
 Oh, well, that's good enough, right?
 And there they all are, right?
 Cat, Lex, Mev, Pax, Ra, Urst, and Rev, and Xev.
 And if you know what all those commands do, you know more than I do.
 All right?
 Any questions on globbing?
 Yes?
 [ Inaudible ]
 This will only match one character, correct.
 All right?
 Other questions on globbing?
 Yes?
 [ Inaudible ]
 If you want to match two or more characters?
 [ Inaudible ]
 There's no operator like the star, like dot star or A
 through Z star, that does not.
 To index from the back end of the sequence by using just minus one here,
 and this is the minus second entry here, work with globbing.
 Globbing has a star which matches zero more characters,
 but there's no way to take an existing pattern and repeat it one
 or more times or anything like that.
 [ Inaudible ]
 Yeah, this looks for every directory entry
 and user bin that has three characters.
 The first character can be anything.
 The second character has to be in the range A through E,
 and the third character has to be in the range T through Z. All right?
 And then after path name expansion, we do redirection,
 which we already talked about last time.
 That's the less than, greater than stuff,
 you know, with all the file names there.
 All right?
 Yes?
 [ Inaudible ]
 Regular expressions are only used with commands like grep.
 There are other commands that use regular N minus two and so forth
 and us like that, right, and then this is the, well,
 this would be the minus entry, and this is the one minus entry.
 Did I get that right?
 Something like that, right?
 So you can index backwards off a sequence, and you'll often see
 in Python code that looks like this when you want
 to get the last element of a list or the last element of a tuple.
 That's very common, all right?
 So the rule for sequences here is that I has to be less than the length
 of S because we started numbering at zero, and it has to be greater than
 or equal to minus the length of S. Oh, and I guess I forgot to tell you.
 There's an operation called length on a sequence.
 It's built in, and it tells you the number of items in the sequence.
 All right, let's try something a little bit more complicated.
 You can also do this for expressions.
 Emacs is one of them.
 It loves regular expressions, right?
 But globbing is, you can think of globbing as being sort of a stripped
 down subset of regular expressions.
 It's not as powerful, but it's more convenient for files.
 This gives you a subsequence of the original sequence.
 So if you think of the sequence as looking like, why not?
 All right, so I'm running Emacs here, and let's visit my home directory.
 So I'll type tilde slash maybe cs35l.
 Here we go, all right.
 And I'm typing control xd, and I am going
 into directory edit mode on this directory.
 Now, this sort of brings up the topic of modes.
 So let me talk about modes in the context of Emacs.
 Emacs is a modeful editor, and here we're talking about user interaction
 design.
 And by modeful editor, I mean this.
 Here's the i-th element.
 Over here is the j-th element.
 You get this subsequence.
 Everything's starting with i and going up to but not including j.
 So i and j have to have the same sort of--
 they have to fall in this range.
 i should be less than or equal to j if they're both non-negative,
 all that good stuff.
 And the length of this value is obviously j minus i.
 And we get that because we're insisting on zero origin indexing all the time.
 When you do this, when you compute this, you compute a subsequence.
 So it's as if you get a nice little subsequence.
 All the values get copied into here.
 Here is your subsequence.
 And it's numbered up from 0 through j minus i minus 1.
 So just as a--
 what does this do?
 What does that expression do for you?
 Yes?
 I cut off the first character in the last.
 Yeah, you get the subsequence by--
 what it will do in response to a command depends on what mode it's in.
 The mode of this editor specifies how it will respond to a command.
 And commands in emacs are keystrokes, right?
 So here we have two buffers.
 At the top, we have sort of the scratch buffer.
 And at the bottom, we have the CS35L buffer.
 If I type, say, control x o, which means-- not control o, control x o,
 that means switch to the other buffer, I will go from this buffer
 for CS35L to the scratch buffer.
 Here, if I type a D, the scratch buffer, like most text buffers,
 if you're popping off the first and the last elements
 of the original sequence, right?
 When is this an error?
 If your sequence is type D, that means please insert the character D, right?
 It's the insert character command.
 And if I type an E, it means insert the character E empty, right?
 It's an error.
 And if it has only one element in it, is it an error?
 Let's try that.
 So we try S equals 23, right?
 And we say S of 1 minus 1.
 We chopped off the first and last element of S,
 and they happen to be the same elements.
 OK?
 So you can get empty sequences this way.
 Yes?
 [INAUDIBLE]
 It includes I, it excludes J, right?
 But you can get empty subsequences as a result of all this.
 There's also this shorthand and this shorthand.
 This means start at element I and go on to the end of the sequence.
 So it's if you--
 and then say type D here.
 Notice I typed D, but we didn't insert the character D.
 We're in directory edit mode in which the commands that you type
 mean something completely different.
 We're still trying, in some sense, to edit this directory.
 But editing directories is so much different from editing files
 that the set of commands that you do and the set of responses
 that you want will be so totally different that Emacs says, no, no.
 They're different modes.
 And D here means, oh, you'd like to delete a file.
 Whereas D up in a text mode means, oh, you
 want to sort of put the character D here in the text.
 Completely different actions.
 So I typed D. It put a D next to the file name.
 In directory edit mode, it's different from editing text files.
 You tell Emacs what you want to do, and it sort of saves it up, right?
 And in the end, you say, oh, well, I'd like to actually execute
 these commands, so I'll type an X here.
 And it will say, oh, do you really want to delete the root?
 And here, I have to type yes or no, so I'll type yes,
 if you put length of S here.
 This means start at the start of the sequence
 and just go up to but not including J. So it's as if you put a zero here.
 All right?
 Other things that work on sequences are this operator.
 This tells you the minimum element of the sequence.
 If you have a sequence of numbers, it will tell you
 the smallest number in that sequence.
 And you can probably guess what this does.
 That gives you the maximum element of the sequence.
 Also, a fairly common operation that you can apply to sequences--
 in some sense, this is something else, but that's all right--
 is you can pass any sequence to the list constructor,
 and it will give you a copy of that sequence in list format
 as opposed to the original format.
 So we can say something like this, list of A, B, C, D, E.
 And that gives you a list of characters.
 So far, I've talked about operations that work on any sequence,
 but there are some operations that work on mutable sequences.
 Look, it's just a symbolic link, right?
 Root is a symbolic link to dot dot slash dot dot slash dot dot dot.
 And it just goes all the way up, and I hope that eventually hits the root.
 And you don't mind if I delete it, right?
 It's OK.
 So I typed yes, and I typed enter, and we have now edited this directory.
 So Emacs, in some sense, you can use it to edit directories,
 and you can use it to edit text files and that sort of thing.
 But the only way that that actually works
 is it keeps different modes for the different things
 you're trying to edit.
 Emacs uses the same idea when you want to edit source code.
 So if I go here and I want to edit, I don't know, foo dot C,
 it now has put me into C mode.
 There is a little C right here.
 It's a little hard to read because it's grayed out.
 But in C mode, Emacs will now treat commands
 that it would otherwise just do normally as something different.
 So if I type something like this, notice
 it's coloring things as I type.
 And then here, I just typed return, and it decided, oh, well, you're
 inside a function, so I'll indent four sequences.
 Only on mutable sequences.
 And the basic one here, of course, is this one.
 This changes the i-th value of the sequence s to be v.
 It's just simple assignments.
 It's like array assignment in C++.
 Question?
 Would min s and max s return none for an empty sequence?
 Let's try it.
 If I'd just been editing a text file and typed return,
 I just would have got a new line.
 But here, I got a new line and a couple of spaces
 because I was in C mode.
 And it said, there's no value here that would work,
 so I'm going to report an error.
 And also, if you give it a sequence full of things that can't be compared,
 it'll throw an error as well.
 You have to give it something that makes sense.
 So this is the basic thing here.
 And all the things we talked about over here work here.
 So you can put a minus 1 here, and that will change
 the last element of the sequence.
 Obviously, if the sequence is empty, it's going to be an error,
 all that good stuff.
 You can also say this.
 This changes a subsequence of i to be the sequence t.
 So this is a more general operation than you might think,
 rather than in ordinary text mode.
 In order to understand how this works,
 you have to know what the commands are
 and what's going to happen when you execute them.
 To find out what the commands are,
 there is a command called control x b -- oops, I'm sorry --
 control x control b. Oh, we'll get there.
 No, no, no, that's buffers.
 We want control x k. We'll get there.
 Control x, control k. What am I doing wrong?
 Help. That's the problem.
 The help button in Emacs is control h.
 If you type control h, that means please give me some help.
 If I type control h k, then you can type a keystroke at Emacs,
 and Emacs will tell you what it's going to do
 if you type this keystroke, right?
 So you type control h k, and then whatever character you like,
 maybe a capital Q. And this means tell me what happens is,
 here's s, right, and you've got i here and j there.
 Over here is t, which is a different sequence,
 possibly of a different length than this length.
 When you're done, if this looks like a a a, b b b b, c c,
 and this is d d d d d, the result looks like this.
 S points to something where you still have the initial part,
 and then here, instead of what you used to have,
 you have d d d d d. And then following that,
 you get c c, right?
 So notice that the resulting s can change in length.
 The length of s has changed to be whatever it used to be,
 plus the length of t, minus j minus i.
 So you can grow s or shrink s using this notation, all right?
 There are some commonly used variants of this.
 You can say this, which is equivalent
 to the earlier statement, except, you know, Q will do,
 without actually doing it, all right?
 So what's going on here is that Emacs is not only modeful,
 it's also self-documenting.
 It wants to tell you how it will work.
 It's part of sort of the open source philosophy.
 It's being very open about what it does, all right?
 So I will type, I don't know, control, no, I'll just type j.
 That's a very simple command.
 So j, if I type j, sitting here when I'm editing this C program,
 it says, well, that just means you're going
 to run the self-insert command.
 The self-insert command just takes the character
 that you typed and says, I want to insert that into the buffer.
 That one's kind of boring.
 So here, if you put the empty sequence here,
 then you'd just be deleting everything.
 Well, this just says, I just want to delete it.
 I don't want to have to tell you that it's the empty sequence.
 Also, this will probably run a little bit faster
 than this one.
 And as a special and important case, you can say this.
 That simply deletes the i-th element of the sequence.
 All right?
 Question?
 >> If you type, if you call the operator on [INAUDIBLE]
 >> Let's try another one.
 Control-H-K, enter.
 All right?
 Enter, or return, which is spelled R-E-T up there,
 says, oh, that runs the command newline.
 And newline says, insert a newline
 and move to the left margin and then do some indenting,
 which is what happened here.
 If I'm interested more in what this command does,
 I can go up here and find the source code
 to the newline command.
 I'll just-- it'll spit out a copy of the list.
 But yes.
 So then you can operate on the copy
 without changing the original.
 Yes?
 >> [INAUDIBLE]
 >> Is there a restriction?
 Well, so lists are mutable.
 So you can do this stuff with lists.
 Topols are not mutable.
 So you cannot do this with topols.
 It's not allowed.
 Other comments on mutable sequence operations?
 All right.
 We have some more operations here
 that are lists only.
 So even other mutable sequences don't necessarily
 support these operations.
 This type return here.
 Here's the source code to the newline command.
 This source code is written in Emacs's main implementation
 language, which is Lisp, or Emacs Lisp, or eLisp for short.
 Lisp has a bunch of parentheses and all that sort of thing.
 The details don't matter here yet.
 I'll get more into the details later.
 But essentially what we're looking at here
 is the source code to Emacs.
 The architecture for Emacs is it's
 a program running under Linux.
 So you have sort of the hardware down here.
 You have the Linux kernel running here.
 You have sort of the C libraries and that sort of thing here.
 The Emacs interpreter is here.
 This is really what you see in the Emacs executable.
 And this Emacs interpreter is written in C.
 So it's a bunch of C files that got compiled.
 But most of Emacs is written in Lisp.
 The simplest one here is append.
 Append grows the list by one and puts
 v at the new end of the list.
 So no matter how long the list used to be, it'll grow by one
 and v's value will be sitting here.
 Now you may say, well, that's just a shorthand way
 of doing something that we could have
 done with our other operators.
 And I suppose we could.
 But the key thing to note about this operation
 is that it's fast.
 How fast?
 Usually it's order one.
 A whole bunch of Lisp code sitting up here.
 And this is in Emacs Lisp files.
 And the bulk of Emacs is written in this higher level language,
 which is the language that you will use most likely if you
 want to tailor Emacs into doing something else.
 Occasionally it'll get longer.
 I mean, the way lists work internally in Python
 is here's the list implementation.
 You have an object here that basically says,
 here are the values.
 This is in use.
 And then here's the size, or the length.
 But then you also keep track of how much is in allocated.
 So the way append works on a list
 is it just bumps the in use counter by one,
 stores the value, done.
 The only problem can be is if you run off.
 The reason I'm sort of going into all this
 is I want you to have the attitude when you're
 looking at any particular program that you need to use,
 like Chrome, or something else like that.
 I want you to have the ability and the confidence
 to go look at the source code to see how it works.
 Now Chrome is a pretty complicated program.
 Emacs is pretty simple by comparison.
 It's an all singing, all dancing IDE,
 but it's one of the simplest ones out there.
 And so next time, what we're going to do
 is we're going to look at some of this elisp code
 and see how it works.
 See how you type q, you jump into here in the lisp code,
 and it figures out what to do with that q,
 and then it puts something up on the screen.
 [AUDIO OUT]
 .
 .
